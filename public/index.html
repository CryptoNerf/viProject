<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#d4d0c8">
    <meta name="description" content="Visualize molecular structures in 3D directly in your browser.">
    <title>Vi-Project</title>

    <!-- Open Graph / Social Media Preview -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Vi-Project">
    <meta property="og:description" content="A tool for creating graphics with gestures.">
    <meta property="og:image" content="https://vi-project.vercel.app/vi-project_preview22.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:url" content="https://vi-project.vercel.app">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Vi-Project">
    <meta name="twitter:description" content="A tool for creating graphics with gestures.">
    <meta name="twitter:image" content="https://vi-project.vercel.app/vi-project_preview22.jpg">
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="molecules_icon.png">
    <link rel="apple-touch-icon" href="molecules_icon.png">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <style>
        @font-face {
            font-family: 'SysfontC';
            src: url('../fonts/SysfontC.woff2') format('woff2'),
                 url('../fonts/SysfontC.woff') format('woff');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SysfontC', 'SysfontC', monospace;
            overflow: hidden;
            background: #ffffff;
            color: #000000;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #videoElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transform: scaleX(-1);
            transition: opacity 0.3s;
            z-index: 1;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #ffffff;
            padding: 16px;
            padding-top: 28px;
            border: 2px solid #000000;
            border-radius: 0;
            box-shadow: 4px 4px 0 rgba(0,0,0,1);
            z-index: 10;
            max-width: 320px;
            transition: transform 0.3s ease, opacity 0.3s ease;
            font-family: 'SysfontC', monospace;
        }

        #controls.minimized {
            transform: translateX(calc(100% + 20px));
            opacity: 0;
            pointer-events: none;
        }

        h2 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #000000;
            font-weight: bold;
            font-family: 'SysfontC', monospace;
            text-transform: uppercase;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            font-size: 14px;
            margin-bottom: 4px;
            color: #000000;
            font-family: 'SysfontC', monospace;
        }

        /* Macintosh System 1.0 стиль для слайдеров */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: transparent;
            cursor: pointer;
            margin: 10px 0;
            border-radius: 0;
            border: black 2px solid;
        }

        /* Трек слайдера (дорожка) - Chrome/Safari */
        input[type="range"]::-webkit-slider-track {
            width: 100%;
            height: 6px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            box-sizing: border-box;
        }

        /* Трек слайдера (дорожка) - Firefox */
        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            box-sizing: border-box;
        }

        /* Ползунок слайдера - Chrome/Safari */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 20px;
            background: #ffffff;
            border: 2px solid #000000;
            cursor: pointer;
            margin-top: 0;
            border-radius: 0;
            box-shadow: none;
            box-sizing: border-box;
        }

        /* Ползунок слайдера - Firefox */
        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 20px;
            background: #ffffff;
            border: 2px solid #000000;
            cursor: pointer;
            border-radius: 0;
            box-shadow: none;
            box-sizing: border-box;
        }

        /* Активный ползунок */
        input[type="range"]:active::-webkit-slider-thumb {
            background: #000000;
        }

        input[type="range"]:active::-moz-range-thumb {
            background: #000000;
        }

        /* Macintosh System 1.0 стиль для чекбоксов */
        input[type="checkbox"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            cursor: pointer;
            position: relative;
            vertical-align: middle;
            margin-right: 6px;
        }

        /* Галочка для отмеченного чекбокса */
        input[type="checkbox"]:checked::before {
            content: '×';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            font-weight: bold;
            color: #000000;
            line-height: 1;
        }

        /* Фокус на чекбоксе */
        input[type="checkbox"]:focus {
            outline: 1px dotted #000000;
            outline-offset: 2px;
        }

        select {
            width: 100%;
            padding: 6px;
            margin-top: 4px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            font-family: 'SysfontC', monospace;
            font-size: 14px;
            color: #000000;
            cursor: pointer;
            box-shadow: 2px 2px 0 #000000;
            accent-color: #000000;
        }

        select:hover {
            background: #dddddd;
        }

        select:focus {
            outline: 2px solid #000000;
            outline-offset: 2px;
        }

        select option {
            background: #ffffff;
            color: #000000;
        }

        select option:checked,
        select option:hover,
        select option:focus,
        select option:active {
            background: #000000 !important;
            color: #ffffff !important;
            background-color: #000000 !important;
        }

        /* Custom select styles */
        .custom-select {
            position: relative;
            width: 100%;
            margin-top: 4px;
        }

        .custom-select-trigger {
            width: 100%;
            padding: 6px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            font-family: 'SysfontC', monospace;
            font-size: 14px;
            color: #000000;
            cursor: pointer;
            box-shadow: 2px 2px 0 #000000;
            text-transform: uppercase;
            box-sizing: border-box;
        }

        .custom-select-trigger:hover {
            background: #dddddd;
        }

        .custom-select-options {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #ffffff;
            border: 2px solid #000000;
            border-top: none;
            box-shadow: 2px 2px 0 #000000;
            z-index: 1000;
            max-height: 200px;
            overflow-y: auto;
        }

        .custom-select.open .custom-select-options {
            display: block;
        }

        .custom-option {
            padding: 6px;
            font-family: 'SysfontC', monospace;
            font-size: 14px;
            color: #000000;
            cursor: pointer;
            text-transform: uppercase;
            background: #ffffff;
        }

        .custom-option:hover {
            background: #000000;
            color: #ffffff;
        }

        .custom-option.selected {
            background: #000000;
            color: #ffffff;
        }

        input[type="color"] {
            border: 2px solid #000000;
            border-radius: 0;
            cursor: pointer;
            background: #ffffff;
        }

        input[type="color"]:hover {
            border-color: #000000;
        }

        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #000000;
            font-weight: bold;
            font-family: 'SysfontC', monospace;
        }

        button {
            width: 100%;
            padding: 6px 12px;
            margin-top: 6px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            color: #000000;
            font-weight: bold;
            cursor: pointer;
            font-family: 'SysfontC', monospace;
            font-size: 14px;
            box-shadow: 2px 2px 0 #000000;
            text-transform: uppercase;
        }

        button:hover {
            background: #dddddd;
        }

        button:active {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .checkbox-group input {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            color: #000000;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: #ffffff;
            padding: 8px 14px;
            font-size: 14px;
            color: #000000;
            box-shadow: 2px 2px 0 #000000;
            border: 2px solid #000000;
            border-radius: 0;
            z-index: 10;
            font-family: 'SysfontC', monospace;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #000000;
            text-align: center;
            z-index: 100;
            font-family: 'SysfontC', monospace;
            text-transform: uppercase;
        }

        .gesture-hint {
            position: absolute;
            top: 20px;
            left: 20px;
            background: #ffffff;
            padding: 15px 20px;
            padding-top: 30px;
            font-size: 14px;
            color: #000000;
            box-shadow: 4px 4px 0 #000000;
            border: 2px solid #000000;
            border-radius: 0;
            max-width: 300px;
            z-index: 10;
            transition: transform 0.3s ease, opacity 0.3s ease;
            font-family: 'SysfontC', monospace;
        }

        .gesture-hint.minimized {
            transform: translateX(calc(-100% - 20px));
            opacity: 0;
            pointer-events: none;
        }

        .gesture-hint strong {
            display: block;
            margin-bottom: 8px;
            color: #000000;
            font-size: 16px;
            text-transform: uppercase;
        }

        .audio-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 40px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            box-shadow: 2px 2px 0 #000000;
            overflow: hidden;
            z-index: 10;
        }

        .audio-bars {
            display: flex;
            align-items: flex-end;
            height: 100%;
            padding: 5px;
            gap: 2px;
        }

        .audio-bar {
            flex: 1;
            background: #000000;
            border-radius: 0;
            transition: height 0.1s;
        }

        /* Кнопки сворачивания панелей */
        .toggle-btn {
            position: absolute;
            width: 36px;
            height: 36px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 11;
            font-size: 18px;
            box-shadow: 2px 2px 0 #000000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            font-family: 'SysfontC', monospace;
        }

        .toggle-btn:hover {
            background: #dddddd;
        }

        .toggle-btn:active {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        #toggleHints {
            top: 20px;
            left: 20px;
            opacity: 1;
            pointer-events: auto;
        }

        #toggleControls {
            top: 20px;
            right: 20px;
        }

        #togglePalette {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .toggle-btn.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* Кнопка закрытия панели */
        .close-panel {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            min-width: 20px;
            min-height: 20px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            cursor: pointer;
            padding: 0;
            margin: 0;
            font-size: 14px;
            line-height: 18px;
            color: #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
            font-family: 'SysfontC', monospace;
            font-weight: bold;
            box-shadow: 2px 2px 0 #000000;
        }

        .close-panel:hover {
            background: #dddddd;
        }

        .close-panel:active {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        /* Скрываем кнопку закрытия палитры на десктопе */
        #closePalette {
            display: none;
        }

        /* Виртуальные кнопки управления для мобильных */
        #virtualControls {
            position: absolute;
            left: 10px;
            bottom: 80px;
            display: none; /* Скрыто по умолчанию, показывается только на мобильных */
            flex-direction: column;
            gap: 10px;
            z-index: 12;
        }

        #virtualControls.active {
            display: flex;
        }

        .virtual-btn {
            width: 50px;
            height: 50px;
            background: #ffffff;
            border: 2px solid #000000;
            border-radius: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
            box-shadow: 2px 2px 0 #000000;
            user-select: none;
            font-family: 'SysfontC', monospace;
        }

        .virtual-btn:active {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        .virtual-btn:hover {
            background: #dddddd;
        }

        .virtual-btn.selected {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        /* Удалено мобильное меню и кнопка menu-toggle-btn - используем только toggleControls */

        /* Адаптация для мобильных устройств */
        @media (max-width: 768px) {
            #controls {
                top: 10px;
                right: 10px;
                padding: 20px;
                padding-top: 30px;
                max-width: calc(100vw - 40px); /* Ширина почти на весь экран с отступами */
                width: 90vw;
                font-size: 14px; /* Увеличен для мобильных */
                background: #ffffff;
                max-height: 85vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
                scrollbar-width: thin; /* Тонкий скроллбар на Firefox */
            }

            /* Стилизация скроллбара для Webkit */
            #controls::-webkit-scrollbar {
                width: 4px;
            }

            #controls::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.05);
                border-radius: 2px;
            }

            #controls::-webkit-scrollbar-thumb {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 2px;
            }

            /* Collapsed state for controls on mobile */
            #controls.mobile-collapsed {
                transform: translateX(calc(100% + 20px));
                opacity: 0;
                pointer-events: none;
            }

            h2 {
                font-size: 20px; /* Увеличен с 14px */
                margin-bottom: 15px;
            }

            h3 {
                font-size: 16px; /* Для подзаголовков */
            }

            .control-group {
                margin-bottom: 0px; /* Увеличены отступы */
            }

            label {
                font-size: 16px; /* Увеличен с 10px */
                line-height: 1.6;
                margin-bottom: 0px;
            }

            button {
                padding: 14px 18px; /* Увеличены отступы для удобного нажатия */
                font-size: 16px; /* Увеличен с 11px */
                margin-top: 10px;
                min-height: 44px; /* Минимальная высота для удобного тапа */
            }

            input[type="range"] {
                height: 32px; /* Увеличена высота слайдера */
                margin: 8px 0;
            }

            input[type="checkbox"] {
                width: 20px;
                height: 20px;
                margin-right: 10px;
            }

            /* Увеличенная галочка для мобильных */
            input[type="checkbox"]:checked::before {
                font-size: 18px;
            }

            .checkbox-group {
                margin-bottom: 15px;
            }

            .checkbox-group label {
                display: flex;
                align-items: center;
                cursor: pointer;
                padding: 8px;
            }

            .gesture-hint {
                top: 10px;
                left: 10px;
                padding: 15px 18px;
                padding-top: 30px;
                font-size: 14px; /* Увеличен для мобильных */
                max-width: 280px;
                background: #ffffff;
            }

            .gesture-hint div {
                line-height: 1.6;
                margin-bottom: 4px;
            }

            .gesture-hint strong {
                font-size: 18px; /* Увеличен заголовок */
            }

            /* Скрываем индикатор режима на мобильных - он перекрывает меню */
            .mode-indicator {
                display: none !important;
            }

            .toggle-btn {
                width: 50px; /* Увеличен с 32px */
                height: 50px;
                font-size: 24px; /* Увеличен с 16px */
            }

            /* Кнопки toggleHints и toggleControls ниже панелей */
            #toggleHints, #toggleControls {
                z-index: 9;
            }

            /* Кнопка togglePalette выше, чтобы быть видимой */
            #togglePalette {
                z-index: 20 !important; /* Выше всех элементов */
                bottom: 15px;
                left: 50%;
                transform: translateX(-50%); /* Центрируем кнопку */
                opacity: 1 !important; /* Принудительно видимая в режиме редактора */
                pointer-events: auto !important; /* Принудительно кликабельная */
            }

            /* Но скрываем когда не в режиме редактора */
            #togglePalette:not(.visible) {
                opacity: 0 !important;
                pointer-events: none !important;
            }

            /* Увеличиваем кнопку закрытия панелей на мобильных */
            .close-panel {
                width: 40px !important;
                height: 40px !important;
                min-width: 40px !important;
                min-height: 40px !important;
                font-size: 28px !important;
                line-height: 40px !important;
                background: #ffffff;
            }

            .close-panel:hover {
                background: #dddddd;
            }

            /* Показываем кнопку закрытия палитры на мобильных */
            #closePalette {
                display: flex !important;
            }

            #toggleHints {
                top: 10px;
                left: 10px;
            }

            #toggleControls {
                top: 10px;
                right: 10px;
            }

            #status {
                bottom: 10px;
                left: 10px;
                padding: 10px 14px;
                font-size: 16px;
            }

            .audio-indicator {
                bottom: 10px;
                right: 10px;
                width: 100px;
                height: 30px;
            }

            .value-display {
                font-size: 16px; /* Увеличен с 11px */
                font-weight: bold;
            }

            /* Mobile-friendly color palette */
            #colorPalette {
                display: block !important; /* Показываем палитру на мобильных, переопределяем базовый display: none */
                left: 50%;
                transform: translateX(-50%);
                width: 95%;
                max-width: 350px;
                padding: 8px;
                padding-top: 25px;
                bottom: 10px;
                max-height: 60vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
                transition: transform 0.3s ease, opacity 0.3s ease; /* Плавная анимация */
                pointer-events: auto !important; /* Разрешаем взаимодействие с палитрой на мобильных */
            }

            #colorPalette::-webkit-scrollbar {
                width: 4px;
            }

            #colorPalette::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.05);
                border-radius: 2px;
            }

            #colorPalette::-webkit-scrollbar-thumb {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 2px;
            }

            #colorPalette.mobile-collapsed {
                transform: translateX(-50%) translateY(calc(100% + 20px));
                opacity: 0;
                pointer-events: none !important; /* Гарантированно блокируем взаимодействие когда скрыта */
            }

            #colorGrid {
                grid-template-columns: repeat(10, 20px); /* Reduce from 14 to 10 columns */
            }

            .color-section {
                margin-bottom: 6px;
            }

            .label-paint {
                font-size: 14px;
            }

            /* Paint toolbar mobile */
            #paintToolbar {
                width: 50px;
                left: 10px;
                padding: 4px;
            }

            .paint-tool {
                width: 20px;
                height: 20px;
                font-size: 14px;
                margin: 2px auto;
            }

            /* Mode indicator smaller on mobile */
            .mode-indicator {
                font-size: 14px;
                padding: 8px 18px;
                top: 15px;
            }
        }


        /* === PAINT РЕЖИМ РЕДАКТОРА === */

        /* УСТАРЕЛО: Панель теперь объединена с #toolbox */
        #paintToolbar {
            display: none !important; /* Полностью скрыта */
        }

        #paintToolbar.active {
            display: block;
        }

        .paint-tool {
            width: 24px;
            height: 24px;
            margin: 3px auto;
            background: #ffffff;
            border: 2px solid #000000;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 2px 2px 0 #000000;
        }

        .paint-tool:hover {
            background: #dddddd;
        }

        .paint-tool:active {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        .paint-tool.selected {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        /* Палитра цветов внизу (как в Paint) */
        #colorPalette {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffffff;
            border: 2px solid #000000;
            box-shadow: 4px 4px 0 #000000;
            padding: 10px;
            padding-top: 25px;
            display: none;
            z-index: 15;
            pointer-events: none; /* Панель прозрачна для событий мыши - можно рисовать сквозь неё */
        }

        #colorPalette.active {
            display: block;
        }

        #colorPalette .color-section {
            margin-bottom: 8px;
        }

        /* Только конкретные интерактивные элементы внутри палитры ловят события */
        #colorPalette button,
        #colorPalette input,
        #colorPalette .color-swatch,
        #colorPalette .color-box,
        #colorPalette label {
            pointer-events: auto;
        }

        #bgClearBtn {
            margin-top: 0px;
        }

        #paletteHandle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: #ffffff;
            border-bottom: 2px solid #000000;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #000000;
            user-select: none;
            pointer-events: auto;
            font-family: 'SysfontC', monospace;
            text-transform: uppercase;
        }

        #paletteHandle:hover {
            background: #dddddd;
        }

        #colorPalette .label-paint {
            font-size: 14px;
            color: #000000;
            font-family: 'SysfontC', monospace;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        #colorGrid {
            display: grid;
            grid-template-columns: repeat(14, 20px);
            gap: 2px;
        }

        .color-swatch {
            width: 20px;
            height: 20px;
            border: 2px solid #000000;
            cursor: pointer;
            box-shadow: none;
        }

        .color-swatch:hover {
            border: 3px solid #000000;
            box-shadow: none;
        }

        .color-swatch.selected {
            border: 4px solid #000000;
        }

        #currentColorDisplay {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .color-box {
            width: 32px;
            height: 32px;
            border: 2px solid #000000;
        }

        .color-label {
            font-size: 14px;
            text-align: center;
            margin-top: 2px;
            color: #000000;
            font-family: 'SysfontC', monospace;
            text-transform: uppercase;
        }

        /* Кнопка переключения режима - наследует стили от обычных кнопок */
        #modeToggleBtn {
            margin-top: 15px;
        }

        /* Индикатор текущего режима */
        .mode-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 20px;
            background: #ffffff;
            border: 2px solid #000000;
            box-shadow: 4px 4px 0 #000000;
            font-size: 16px;
            font-weight: bold;
            z-index: 16;
            display: none;
            font-family: 'SysfontC', monospace;
            color: #000000;
            text-transform: uppercase;
        }

        .mode-indicator.active {
            display: block;
        }

        .mode-indicator.gesture-mode {
            background: #ffffff;
            color: #000000;
            border: 2px solid #000000;
        }

        .mode-indicator.editor-mode {
            background: #ffffff;
            color: #000000;
            border: 2px solid #000000;
        }

        /* Кнопки режима заливки */
        .fill-mode-btn {
            flex: 1;
            padding: 4px 8px;
            font-size: 14px;
            background: #ffffff;
            border: 2px solid #000000;
            cursor: pointer;
            font-family: 'SysfontC', monospace;
            color: #000000;
            box-shadow: 2px 2px 0 #000000;
            text-transform: uppercase;
        }

        .fill-mode-btn:hover {
            background: #dddddd;
        }

        .fill-mode-btn:active {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        .fill-mode-btn.active {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        /* === ПАНЕЛЬ ИНСТРУМЕНТОВ === */
        #toolbox {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: #ffffff;
            padding: 10px;
            border: 2px solid #000000;
            box-shadow: 4px 4px 0 #000000;
            z-index: 15;
            font-family: 'SysfontC', monospace;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #toolbox.minimized {
            transform: translate(calc(-100% - 20px), -50%);
            opacity: 0;
            pointer-events: none;
        }

        .toolbox-section {
            margin-bottom: 15px;
        }

        .toolbox-section:last-child {
            margin-bottom: 0;
        }

        .toolbox-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #000000;
            text-align: center;
            padding: 4px;
            background: #ffffff;
            border: 2px solid #000000;
            text-transform: uppercase;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .tool-btn {
            width: 60px;
            height: 60px;
            padding: 4px;
            margin: 0;
            background: #ffffff;
            border: 2px solid #000000;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: none;
            box-shadow: 2px 2px 0 #000000;
        }

        .tool-btn:hover {
            background: #dddddd;
        }

        .tool-btn:active, .tool-btn.active {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        .tool-label {
            display: none; /* Скрываем подписи */
        }

        .tool-icon {
            width: 48px; /* Увеличен размер */
            height: 48px;
            object-fit: contain;
            pointer-events: none; /* Чтобы клики проходили на кнопку */
        }

        .action-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
        }

        .action-btn {
            width: 100%;
            padding: 10px 4px;
            margin: 0;
            font-size: 20px;
            background: #ffffff;
            border: 2px solid #000000;
            cursor: pointer;
            white-space: nowrap;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 2px 2px 0 #000000;
        }

        .action-btn:hover {
            background: #dddddd;
        }

        .action-btn:active {
            background: #000000;
            color: #ffffff;
            box-shadow: none;
        }

        .action-btn:disabled {
            color: #808080;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .action-btn img {
            width: 32px;
            height: 32px;
            object-fit: contain;
        }

        /* Мобильная адаптация панели инструментов */
        @media (max-width: 768px) {
            #toolbox {
                top: auto;
                bottom: 70px;
                left: 10px;
                transform: none;
                padding: 8px;
                max-height: calc(100vh - 150px);
                overflow-y: auto;
            }

            #toolbox.minimized {
                transform: translateX(calc(-100% - 10px));
                opacity: 0;
            }

            .tool-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            .tool-icon {
                width: 40px; /* Увеличен для мобильных */
                height: 40px;
            }

            .action-btn {
                font-size: 18px;
                padding: 8px 2px;
            }

            .action-btn img {
                width: 28px; /* Увеличен для мобильных */
                height: 28px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="videoElement" autoplay playsinline></video>
        <canvas id="canvas"></canvas>

        <div class="toggle-btn" id="toggleHints" title="Open manual book">?</div>

        <!-- Toolbox -->
        <div id="toolbox">
            <!-- Tools -->
            <div class="toolbox-section">
                <div class="toolbox-title">Tools</div>
                <div class="tool-grid">
                    <button class="tool-btn active" id="tool-select" title="Select molecule: mouse = move, Ctrl+mouse = size, Shift+mouse = stretch, Alt+mouse = rotate, wheel = size. Ctrl+C/V to copy">
                        <img src="icons/select.png" alt="Select" class="tool-icon">
                        <div class="tool-label">Select</div>
                    </button>
                    <button class="tool-btn" id="tool-create" title="Create molecule (click anywhere)">
                        <img src="icons/create.png" alt="Create" class="tool-icon">
                        <div class="tool-label">Create</div>
                    </button>
                    <button class="tool-btn" id="tool-delete" title="Delete molecule (click on molecule)">
                        <img src="icons/delete.png" alt="Delete" class="tool-icon">
                        <div class="tool-label">Delete</div>
                    </button>
                </div>
            </div>

            <!-- Selected molecule actions -->
            <div class="toolbox-section">
                <div class="toolbox-title">Selected</div>
                <div class="action-grid">
                    <button class="action-btn" id="action-lock" title="Lock selected molecule">
                        <img src="icons/lock.png" alt="Lock">
                    </button>
                    <button class="action-btn" id="action-unlock" title="Unlock selected molecule">
                        <img src="icons/unlock.png" alt="Unlock">
                    </button>
                </div>
            </div>

            <!-- Paint tools -->
            <div class="toolbox-section" id="paintToolsSection" style="display: none;">
                <div class="toolbox-title">Paint</div>
                <div class="tool-grid">
                    <button class="tool-btn paint-tool-btn" data-tool="fill" title="Fill molecule with color">
                        <img src="icons/fill.png" alt="Fill" class="tool-icon">
                        <div class="tool-label">Fill</div>
                    </button>
                    <button class="tool-btn paint-tool-btn" data-tool="pencil" title="Draw with pencil">
                        <img src="icons/pencil.png" alt="Pencil" class="tool-icon">
                        <div class="tool-label">Pencil</div>
                    </button>
                    <button class="tool-btn paint-tool-btn" data-tool="eraser" title="Erase drawing">
                        <img src="icons/eraser.png" alt="Eraser" class="tool-icon">
                        <div class="tool-label">Eraser</div>
                    </button>
                </div>
            </div>
        </div>

        <div class="toggle-btn" id="toggleToolbox" title="Show toolbox" style="left: 20px; top: 20px;">≡</div>

        <div id="controls">
            <button class="close-panel" id="closeControls" title="Hide panel">×</button>
            <h2>Settings</h2>

            <div class="control-group">
                <label>Molecule size: <span class="value-display" id="molSize">100</span></label>
                <input type="range" id="molSizeSlider" min="50" max="300" value="100" step="10">
            </div>

            <div class="control-group">
                <label>Molecule shape:</label>
                <select id="shapeSelector" style="display: none;">
                    <option value="circle">● Circle</option>
                    <option value="triangle">▲ Triangle</option>
                    <option value="heart">♥ Heart</option>
                    <option value="star">★ Star</option>
                </select>
                <div class="custom-select">
                    <div class="custom-select-trigger">● CIRCLE</div>
                    <div class="custom-select-options">
                        <div class="custom-option" data-value="circle">● CIRCLE</div>
                        <div class="custom-option" data-value="triangle">▲ TRIANGLE</div>
                        <div class="custom-option" data-value="heart">♥ HEART</div>
                        <div class="custom-option" data-value="star">★ STAR</div>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <label>Merge strength: <span class="value-display" id="mergeStrength">1.5</span></label>
                <input type="range" id="mergeSlider" min="0.5" max="3" value="1.5" step="0.1">
            </div>

            <div class="control-group">
                <label>Audio reaction: <span class="value-display" id="audioSens">20</span></label>
                <input type="range" id="audioSensSlider" min="5" max="50" value="20" step="5">
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="audioEnabled" checked>
                <label for="audioEnabled">Sound affects shape</label>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="showVideo">
                <label for="showVideo">Show video</label>
            </div>

            <button id="lockBtn">Lock all</button>
            <button id="unlockBtn">Unlock all</button>
            <button id="clearBtn">Clear all</button>
            <button id="modeToggleBtn">Editor mode</button>

            <h3 style="margin-top: 15px; margin-bottom: 8px; font-size: 16px; border-top: 2px solid #000000; padding-top: 10px; text-transform: uppercase;">Export</h3>

            <div class="checkbox-group">
                <input type="checkbox" id="exportWithBackground" checked>
                <label for="exportWithBackground">With background</label>
            </div>

            <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px;">
                <button id="exportPngBtn">Export PNG</button>
                <button id="recordVideoBtn">
                    <span id="recordBtnText">Record video (30 sec)</span>
                </button>
            </div>
        </div>

        <div class="toggle-btn" id="toggleControls" title="Show panel">≡</div>

        <div class="audio-indicator">
            <div class="audio-bars" id="audioBars"></div>
        </div>

        <div id="status">Loading...</div>
        <div class="loading" id="loading">
            <div>Initializing...</div>
            <div style="font-size: 14px; margin-top: 10px;">Allow camera and microphone access</div>
        </div>

        <!-- Mode indicator -->
        <div class="mode-indicator gesture-mode active" id="modeIndicator">
            Gesture mode
        </div>

        <!-- Paint toolbar -->
        <div id="paintToolbar">
            <div class="paint-tool selected" data-tool="fill" title="Fill">■</div>
            <div class="paint-tool" data-tool="pencil" title="Pencil">✎</div>
            <div class="paint-tool" data-tool="eraser" title="Eraser">⌫</div>
        </div>

        <!-- Paint color palette -->
        <div id="colorPalette">
            <button class="close-panel" id="closePalette" title="Hide palette">×</button>
            <div id="paletteHandle">⋮⋮ Drag to move ⋮⋮</div>
            <div class="color-section">
                <div class="label-paint">Colors:</div>
                <div id="colorGrid"></div>
            </div>
            <div class="color-section">
                <div class="label-paint">Current color:</div>
                <div id="currentColorDisplay">
                    <div>
                        <div class="color-box" id="primaryColor" style="background: #000000;"></div>
                        <div class="color-label">For molecules</div>
                    </div>
                </div>
            </div>
            <div class="color-section">
                <div class="label-paint">Custom molecule color:</div>
                <div style="margin-top: 5px;">
                    <input type="color" id="customPrimaryColor" value="#000000" style="width: 100%; height: 35px; border: 2px solid #999; cursor: pointer;" title="Choose custom color for filling molecules">
                </div>
            </div>
            <div class="color-section">
                <div class="label-paint" id="fillModeLabel">Fill mode:</div>
                <div style="display: flex; gap: 5px; margin-top: 5px;">
                    <button class="fill-mode-btn active" data-mode="both" title="Both">Both</button>
                    <button class="fill-mode-btn" data-mode="interior" title="Interior only">Interior</button>
                    <button class="fill-mode-btn" data-mode="edge" title="Edge only">Edge</button>
                </div>
            </div>
            <div class="color-section">
                <div class="label-paint">Effects:</div>
                <div style="margin-top: 5px; display: flex; flex-direction: column; gap: 3px;">
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 14px; cursor: pointer;">
                        <input type="checkbox" id="embossEffect" style="cursor: pointer;">
                        <span>Emboss</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; font-size: 14px; cursor: pointer;">
                        <input type="checkbox" id="microStripesEffect" style="cursor: pointer;">
                        <span>Micro-stripes</span>
                    </label>
                    <div id="microStripesSettings" style="display: none; margin-left: 20px; margin-top: 5px; padding: 8px; background: #ffffff; border: 2px solid #000000; border-radius: 0; gap: 8px; flex-direction: column;">
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <label style="font-size: 14px; color: #000000; text-transform: uppercase;">Color 1:</label>
                            <input type="color" id="stripeColor1" value="#ff0000" style="width: 100%; height: 25px; border: 2px solid #000000; cursor: pointer;">
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <label style="font-size: 14px; color: #000000; text-transform: uppercase;">Color 2:</label>
                            <input type="color" id="stripeColor2" value="#0000ff" style="width: 100%; height: 25px; border: 2px solid #000000; cursor: pointer;">
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <label style="font-size: 14px; color: #000000; text-transform: uppercase;">Width: <span id="stripeWidthValue">2</span>px</label>
                            <input type="range" id="stripeWidth" min="1" max="10" value="2" style="width: 100%; cursor: pointer;">
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <label style="font-size: 14px; color: #000000; text-transform: uppercase;">Spacing: <span id="stripeSpacingValue">3</span>px</label>
                            <input type="range" id="stripeSpacing" min="2" max="15" value="3" style="width: 100%; cursor: pointer;">
                        </div>
                    </div>
                </div>
            </div>
            <div class="color-section">
                <div class="label-paint" id="pencilToolLabel">Pencil:</div>
                <div style="margin-top: 5px; display: flex; flex-direction: column; gap: 8px;">
                    <div style="display: flex; flex-direction: column; gap: 4px;">
                        <label style="font-size: 14px;">Thickness: <span id="pencilWidthValue">3</span>px</label>
                        <input type="range" id="pencilWidth" min="1" max="20" value="3" style="width: 100%; cursor: pointer;">
                    </div>
                    <div class="checkbox-group" id="smartEraserCheckbox" style="display: none;">
                        <input type="checkbox" id="smartEraser">
                        <label for="smartEraser" style="font-size: 14px;">Smart eraser (deletes whole)</label>
                    </div>
                    <button id="clearDrawings" style="padding: 6px 12px; cursor: pointer; font-size: 14px; background: #ffffff; color: #000000; border: 2px solid #000000; border-radius: 0; box-shadow: 2px 2px 0 #000000; text-transform: uppercase;">Clear all pencil</button>
                </div>
            </div>
            <div class="color-section">
                <div class="label-paint">Canvas background:</div>
                <div style="display: flex; gap: 5px; margin-top: 5px; flex-wrap: wrap;">
                    <input type="color" id="bgColorPicker" value="#ffffff" title="Canvas background color" style="width: 50px; height: 30px; border: 2px solid #000000; cursor: pointer;">
                    <label class="fill-mode-btn" style="padding: 4px 8px; cursor: pointer; flex: 1; min-width: 70px; text-align: center;">
                        File
                        <input type="file" id="bgFilePicker" accept="image/*,video/*" style="display: none;">
                    </label>
                    <button class="fill-mode-btn" id="bgClearBtn" title="Clear background">✖</button>
                </div>
                <div id="bgPreview" style="margin-top: 5px; font-size: 14px; color: #000000;"></div>
            </div>
        </div>

        <div class="toggle-btn" id="togglePalette" title="Show palette">▼</div>

        <!-- Virtual control buttons for mobile devices -->
        <div id="virtualControls">
            <div class="virtual-btn" data-action="create" title="Create molecule">+</div>
            <div class="virtual-btn" data-action="delete" title="Delete molecule">×</div>
            <div class="virtual-btn" data-action="move" title="Move molecule">↔</div>
            <div class="virtual-btn" data-action="scale-up" title="Increase size">▲</div>
            <div class="virtual-btn" data-action="scale-down" title="Decrease size">▼</div>
        </div>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <script>
        // Отключение Service Worker если он был зарегистрирован ранее
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(registrations => {
                for (let registration of registrations) {
                    registration.unregister();
                    console.log('Service Worker удален');
                }
            });
        }

        // === ОПРЕДЕЛЕНИЕ МОБИЛЬНОГО УСТРОЙСТВА ===
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ||
                        ('ontouchstart' in window) ||
                        (navigator.maxTouchPoints > 0);

        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        console.log('Мобильное устройство:', isMobile);
        console.log('Поддержка touch:', isTouchDevice);

        // === ПЕРЕМЕННЫЕ ДЛЯ TOUCH УПРАВЛЕНИЯ ===
        let touchMode = isMobile ? 'create' : null; // Режимы: create, move, scale, delete
        let activeTouches = new Map(); // Активные касания
        let initialPinchDistance = 0; // Для pinch-to-zoom
        let touchedMolecule = null; // Молекула которую трогают

        // Основные переменные
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('videoElement');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');

        let width, height;
        let molecules = [];
        let hands = [];
        let previousPinchStates = [false, false];
        let audioLevel = 0;
        let audioFrequencyData = [];
        let isMouthOpen = false; // Текущее состояние рта
        let wasMouthOpen = false; // Предыдущее состояние рта для детекции открытия
        let mouthOpenFrames = 0; // Счётчик кадров с открытым ртом для стабилизации
        let editingMolecule = null; // Молекула в режиме редактирования
        let hoveredMolecule = null; // Молекула на которую наведена рука СЕЙЧАС
        let lastHoveredMolecule = null; // Последняя молекула на которую наводились

        // === РЕЖИМ РЕДАКТОРА ===
        let editorMode = false; // false = жесты, true = редактор
        let frozenMolecules = []; // Замороженные молекулы для редактирования
        let selectedMolecule = null; // Выбранная молекула в редакторе
        let hoveredMoleculeEditor = null; // Молекула под курсором в редакторе

        let currentTool = 'fill'; // Текущий инструмент (fill, pencil, eraser)
        let primaryColor = '#000000'; // Основной цвет
        let secondaryColor = '#ffffff'; // Фоновый цвет
        let fillMode = 'both'; // Режим заливки: 'interior' (внутренность), 'edge' (контур), 'both' (оба)

        // === ИКОНКИ ЖЕСТОВ ===
        const gestureIcons = {
            open: new Image(),
            lock: new Image(),
            unlock: new Image(),
            delete: new Image()
        };
        gestureIcons.open.src = 'icons/open_hand.png';
        gestureIcons.lock.src = 'icons/lock_hand.png';
        gestureIcons.unlock.src = 'icons/unlock_hand.png';
        gestureIcons.delete.src = 'icons/delete_hand.png';
        let gestureIconsLoaded = false;
        Promise.all([
            new Promise(resolve => gestureIcons.open.onload = resolve),
            new Promise(resolve => gestureIcons.lock.onload = resolve),
            new Promise(resolve => gestureIcons.unlock.onload = resolve),
            new Promise(resolve => gestureIcons.delete.onload = resolve)
        ]).then(() => {
            gestureIconsLoaded = true;
            console.log('Gesture icons loaded');
        });

        // === ФОРМЫ МОЛЕКУЛ ===
        let selectedShape = 'circle'; // Выбранная форма для создания молекул

        // === UI ИНСТРУМЕНТЫ ДЛЯ МОЛЕКУЛ ===
        let moleculeTool = 'select'; // select, create, delete
        let selectedMoleculeUI = null; // Молекула выбранная через UI
        let isDraggingMolecule = false; // Флаг перетаскивания/редактирования молекулы
        let dragOffsetX = 0; // Смещение курсора относительно центра молекулы
        let dragOffsetY = 0;
        let editStartX = 0; // Начальная позиция для редактирования
        let editStartY = 0;
        let editStartRadius = 0; // Начальный размер молекулы
        let editStartStretchX = 1; // Начальное растяжение по X
        let editStartStretchY = 1; // Начальное растяжение по Y
        let editStartAngle = 0; // Начальный угол поворота
        let copiedMolecule = null; // Буфер обмена для молекул
        let lastMouseX = 0; // Последняя позиция мыши для вставки
        let lastMouseY = 0;

        // Настройки карандаша
        let pencilWidth = 3; // Толщина карандаша в пикселях
        let smartEraserMode = false; // Режим умного ластика (удаляет целиком по клику)
        let drawnStrokes = []; // Массив нарисованных штрихов { points: [{x, y}], color: string, width: number }
        let currentStroke = null; // Текущий рисуемый штрих
        let isDrawing = false; // Флаг рисования
        let filledRegions = []; // Массив залитых областей { imageData: ImageData, x: number, y: number, width: number, height: number }
        let backgroundFills = []; // Массив фоновых заливок (рисуются под молекулами)

        // История для отмены действий (Ctrl+Z)
        let history = []; // Стек состояний
        const MAX_HISTORY_SIZE = 50; // Максимальное количество сохраненных состояний

        // Фон
        let backgroundColor = '#ffffff'; // Цвет фона
        let backgroundImage = null; // Изображение фона (Image или video элемент)
        let backgroundType = 'color'; // 'color', 'image', 'video'

        // Кеширование фона для производительности
        let backgroundCache = null; // OffscreenCanvas для кеширования фона
        let backgroundCacheCtx = null;
        let backgroundCacheValid = false; // Флаг валидности кеша

        // Палитра Paint (28 классических цветов)
        const paintColors = [
            '#000000', '#808080', '#800000', '#808000', '#008000', '#008080', '#000080', '#800080',
            '#808000', '#FFFFFF', '#C0C0C0', '#FF0000', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF',
            '#FF00FF', '#FFFF80', '#80FFFF', '#FF8080', '#8080FF', '#FF80FF', '#804040', '#408080',
            '#804080', '#408040', '#FF8040', '#80FF40'
        ];

        // Сглаживание жестов - храним историю последних 10 кадров (УЛУЧШЕНО: было 5)
        // Больше истории = более стабильная детекция, меньше ложных срабатываний
        const GESTURE_HISTORY_SIZE = 10;
        let gestureHistory = []; // Массив из последних N состояний рук

        // УЛУЧШЕНО v6: Сбалансированные требования - золотая середина
        // Это предотвращает "слетание" жестов и ложные срабатывания
        const GESTURE_STABILITY = {
            pinch: { required: 4, history: [] },      // Щипок - требует 4 из 10 кадров (40%) - СМЯГЧЕНО для стабильности
            pinky: { required: 5, history: [] },      // Мизинец - требует 5 из 10 (50%) - УСИЛЕНО для меньше ложных срабатываний
            crossed: { required: 6, history: [] },    // Скрещенные - требует 6 из 10 (60%)
            fist: { required: 4, history: [] },       // Все пальцы вместе - требует 4 из 10 (40%) - СМЯГЧЕНО для стабильности
            open: { required: 3, history: [] }        // Открытая ладонь - требует 3 из 10 (30%)
        };

        // НОВОЕ: Умная стабилизация движений рук в режиме редактирования
        const HAND_SMOOTHING_WINDOW = 5; // Количество кадров для сглаживания
        let handPositionHistory = []; // История позиций рук для сглаживания

        // Функция сглаживания позиций рук (moving average)
        function smoothHandPositions(currentHands) {
            // Добавляем текущие позиции в историю
            handPositionHistory.push(currentHands.map(h => ({
                x: h.x,
                y: h.y,
                handWidth: h.handWidth
            })));

            // Ограничиваем размер истории
            if (handPositionHistory.length > HAND_SMOOTHING_WINDOW) {
                handPositionHistory.shift();
            }

            // Если истории недостаточно - возвращаем текущие позиции
            if (handPositionHistory.length < 2) {
                return currentHands;
            }

            // Вычисляем сглаженные позиции
            const smoothedHands = currentHands.map((hand, handIndex) => {
                let sumX = 0, sumY = 0, sumWidth = 0;
                let count = 0;

                // Берём позиции из истории для этой руки
                handPositionHistory.forEach(frame => {
                    if (frame[handIndex]) {
                        sumX += frame[handIndex].x;
                        sumY += frame[handIndex].y;
                        sumWidth += frame[handIndex].handWidth;
                        count++;
                    }
                });

                // Применяем веса - более свежие позиции важнее
                // Экспоненциальное сглаживание
                const alpha = 0.3; // Коэффициент сглаживания (0 = только история, 1 = только текущее)
                const avgX = sumX / count;
                const avgY = sumY / count;
                const avgWidth = sumWidth / count;

                return {
                    ...hand,
                    x: hand.x * alpha + avgX * (1 - alpha),
                    y: hand.y * alpha + avgY * (1 - alpha),
                    handWidth: hand.handWidth * alpha + avgWidth * (1 - alpha)
                };
            });

            return smoothedHands;
        }

        // Таймеры для фиксации и удаления
        const HOLD_DURATION = 1000; // 1 секунда в миллисекундах (было 2000)
        const RESET_TOLERANCE = 200; // Толерантность перед сбросом таймера (мс)
        let fistHoldStart = null; // Время начала удержания жеста "пальцы вместе" на молекуле
        let twoFistsHoldStart = null; // Время начала удержания жеста двумя руками
        let fistHoldMolecule = null; // Молекула, над которой удерживается жест
        let crossedHoldStart = null; // Время начала удержания скрещенных пальцев
        let crossedHoldMolecule = null; // Молекула, которую хотят удалить
        let crossedHoldLostTime = null; // Время когда жест был потерян
        let pinchHoldStarts = [null, null]; // Время начала удержания pinch для каждой руки
        let pinchCreatedFlags = [false, false]; // Флаги: была ли уже создана молекула для каждой руки
        let pinchReleaseTime = [null, null]; // Время когда pinch был отпущен (для предотвращения двойного создания)

        let config = {
            moleculeSize: 150, // УВЕЛИЧЕНО: было 100, теперь 150 - более заметный начальный размер
            mergeStrength: 1.5,
            audioSensitivity: 20,
            audioEnabled: true,
            showVideo: false
        };

        // Адаптивные размеры молекул (обновляются в resize())
        let minMoleculeSize = 30;  // Минимальный размер молекулы
        let maxMoleculeSize = 300; // Максимальный размер молекулы

        // Аудио контекст
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let dataArray = null;

        // Параметры метаболлов
        // Мобильные устройства получают пониженное качество по умолчанию для лучшей производительности
        let gridResolution = isMobile ? 15 : 10; // Разрешение сетки для marching squares (уменьшено для лучшей детализации)
        const baseGridResolution = isMobile ? 15 : 10; // Базовое разрешение для хорошей детализации сердца
        const lowQualityGridResolution = isMobile ? 25 : 20; // Низкое качество при высокой нагрузке
        let currentFillResolution = isMobile ? 6 : 4; // Текущее разрешение заливки (адаптивное)

        // Ограничение количества молекул на мобильных для производительности
        const maxMolecules = isMobile ? 30 : 100;

        // Система мониторинга производительности
        let frameTimeHistory = [];
        const frameTimeHistorySize = 10; // Усреднение по последним 10 кадрам
        let isLowPerformanceMode = isMobile; // На мобильных начинаем с режима низкой производительности

        // Пространственное разбиение для оптимизации (Spatial Hashing)
        const spatialCellSize = 150; // Размер ячейки пространственной сетки (должен быть >= максимального радиуса влияния молекулы)
        let spatialHash = new Map(); // Хеш-таблица: ключ = "x,y" координаты ячейки, значение = массив молекул

        // Функция построения пространственного хеша
        function buildSpatialHash(moleculesToHash = molecules) {
            spatialHash.clear();

            for (const mol of moleculesToHash) {
                // Вычисляем радиус влияния молекулы с учётом растяжения
                // Для вытянутых молекул радиус влияния больше
                const maxStretch = Math.max(mol.stretchX || 1, mol.stretchY || 1);
                const influenceRadius = mol.size * maxStretch * 2.5; // Запас для вытянутых молекул

                // Находим все ячейки, которые могут быть затронуты этой молекулой
                const minCellX = Math.floor((mol.x - influenceRadius) / spatialCellSize);
                const maxCellX = Math.floor((mol.x + influenceRadius) / spatialCellSize);
                const minCellY = Math.floor((mol.y - influenceRadius) / spatialCellSize);
                const maxCellY = Math.floor((mol.y + influenceRadius) / spatialCellSize);

                // Добавляем молекулу во все затронутые ячейки
                for (let cy = minCellY; cy <= maxCellY; cy++) {
                    for (let cx = minCellX; cx <= maxCellX; cx++) {
                        const key = `${cx},${cy}`;
                        if (!spatialHash.has(key)) {
                            spatialHash.set(key, []);
                        }
                        spatialHash.get(key).push(mol);
                    }
                }
            }
        }

        // Функция получения молекул, которые могут влиять на точку (x, y)
        function getNearbyMolecules(x, y) {
            const cellX = Math.floor(x / spatialCellSize);
            const cellY = Math.floor(y / spatialCellSize);
            const key = `${cellX},${cellY}`;
            return spatialHash.get(key) || [];
        }

        // Функция адаптации качества рендеринга на основе производительности
        function adaptRenderingQuality(frameTime) {
            // Добавляем время кадра в историю
            frameTimeHistory.push(frameTime);
            if (frameTimeHistory.length > frameTimeHistorySize) {
                frameTimeHistory.shift();
            }

            // Вычисляем среднее время кадра
            const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;

            // Целевое время кадра - на мобильных целимся в 30 FPS для экономии батареи
            const targetFrameTime = isMobile ? 33.33 : 16.67; // 30 FPS для мобильных, 60 FPS для десктопа
            const criticalFrameTime = isMobile ? 66.67 : 50; // 15 FPS для мобильных, 20 FPS для десктопа

            // Адаптивное изменение качества
            if (avgFrameTime > criticalFrameTime && !isLowPerformanceMode) {
                // Переключаемся в режим низкой производительности
                isLowPerformanceMode = true;
                gridResolution = lowQualityGridResolution;
                currentFillResolution = 8; // Увеличиваем шаг заливки
                console.log('⚠️ Режим низкой производительности активирован');

                // На мобильных автоматически отключаем дорогие эффекты
                if (isMobile) {
                    const embossCheckbox = document.getElementById('embossEffect');
                    const microStripesCheckbox = document.getElementById('microStripesEffect');
                    if (embossCheckbox) embossCheckbox.checked = false;
                    if (microStripesCheckbox) microStripesCheckbox.checked = false;
                }
            } else if (avgFrameTime < targetFrameTime * 1.5 && isLowPerformanceMode && !isMobile) {
                // Возвращаемся к нормальному качеству (только на десктопе, мобильные остаются в режиме экономии)
                isLowPerformanceMode = false;
                gridResolution = baseGridResolution;
                currentFillResolution = 4;
                console.log('✅ Возврат к нормальному качеству');
            } else if (avgFrameTime > targetFrameTime && avgFrameTime <= criticalFrameTime && !isLowPerformanceMode) {
                // Средняя производительность - немного снижаем качество
                gridResolution = Math.floor((baseGridResolution + lowQualityGridResolution) / 2); // 20
                currentFillResolution = 6;
            }
        }

        // === SDF (Signed Distance Field) функции для форм ===
        // Эти функции возвращают расстояние от точки до границы формы

        // SDF для треугольника (равносторонний)
        function sdfTriangle(px, py, cx, cy, size) {
            // Смещаем к центру
            let x = px - cx;
            let y = py - cy;

            // Масштабируем к единичному треугольнику
            const radius = size / 2;
            x /= radius;
            y /= radius;

            const k = Math.sqrt(3.0);

            // Отражаем по x для симметрии
            x = Math.abs(x) - 1.0;
            y = y + 1.0 / k;

            // Обрезаем до треугольника
            if (x + k * y > 0.0) {
                const newX = (x - k * y) / 2.0;
                y = (-k * x - y) / 2.0;
                x = newX;
            }

            x -= Math.max(-2.0, Math.min(x, 0.0));

            return -Math.sqrt(x * x + y * y) * Math.sign(y) * radius;
        }

        // SDF для сердца
        function sdfHeart(px, py, cx, cy, size) {
            // Нормализуем координаты
            let x = (px - cx) / size;
            let y = (py - cy) / size;

            // Переворачиваем Y для правильной ориентации (сердце смотрит вниз)
            y = -y;

            // Масштабируем и центрируем
            x *= 1.7;  // Немного уменьшен для более широкого сердца
            y *= 1.7;
            y += 0.2;  // Смещение вниз

            // УЛУЧШЕННАЯ ФОРМУЛА СЕРДЦА с глубоким углублением
            // Основана на уравнении: (x² + y² - 1)³ - x²y³ = 0

            const x2 = x * x;
            const y2 = y * y;

            // Основная формула сердца
            const a = x2 + y2 - 1.0;

            // Увеличен коэффициент для БОЛЕЕ ГЛУБОКОГО углубления между долями
            // Чем больше коэффициент, тем глубже углубление
            const heartEq = a * a * a - x2 * y * y * y * 1.15;

            // Вычисляем приблизительное расстояние
            // Используем корень 6-й степени для сглаживания
            const dist = Math.sign(heartEq) * Math.pow(Math.abs(heartEq), 1.0 / 6.0);

            return dist * size * 0.5;
        }

        // SDF для звезды (5-конечная)
        function sdfStar(px, py, cx, cy, size) {
            let x = px - cx;
            let y = py - cy;

            // Нормализуем
            const radius = size / 2;
            x /= radius;
            y /= radius;

            // 5-конечная звезда с более выраженными лучами
            const n = 5.0; // Количество лучей
            const m = 2.0; // Количество пропускаемых вершин (для пентаграммы)

            // Полярные координаты
            const r = Math.sqrt(x * x + y * y);
            let angle = Math.atan2(y, x);

            // Нормализуем угол в диапазон одного сектора
            const an = Math.PI * 2.0 / n;
            angle = ((angle + Math.PI) % an) - an / 2.0;

            // Внутренний и внешний радиусы звезды
            const outerR = 1.0;
            const innerR = 0.4; // Меньше значение = более острые лучи

            // Вычисляем SDF для треугольного луча
            const cosAngle = Math.cos(angle);
            const px2 = r * cosAngle;
            const py2 = Math.abs(r * Math.sin(angle));

            // Граница между внутренним и внешним радиусом
            const angleAtInner = Math.asin(innerR * Math.sin(an / 2.0));
            const k = Math.tan(an / 2.0 - angleAtInner);

            // Расстояние до края луча
            const dist1 = py2 - k * (px2 - outerR);
            const dist2 = px2 - outerR;
            const dist3 = innerR - r;

            const dist = Math.max(dist1, Math.max(dist2, dist3));

            return dist * radius;
        }

        // SDF для круга (для единообразия)
        function sdfCircle(px, py, cx, cy, size) {
            const dx = px - cx;
            const dy = py - cy;
            return Math.sqrt(dx * dx + dy * dy) - size / 2;
        }

        // Функции для рисования разных форм
        function drawTriangle(ctx, x, y, size) {
            const height = size * Math.sqrt(3) / 2;
            ctx.beginPath();
            ctx.moveTo(x, y - height * 0.6);
            ctx.lineTo(x - size / 2, y + height * 0.4);
            ctx.lineTo(x + size / 2, y + height * 0.4);
            ctx.closePath();
        }

        function drawHeart(ctx, x, y, size) {
            const scale = size / 50; // Нормализация к размеру
            ctx.beginPath();
            ctx.moveTo(x, y + 10 * scale);
            // Левая дуга
            ctx.bezierCurveTo(
                x - 25 * scale, y - 15 * scale,
                x - 50 * scale, y + 10 * scale,
                x, y + 40 * scale
            );
            // Правая дуга
            ctx.bezierCurveTo(
                x + 50 * scale, y + 10 * scale,
                x + 25 * scale, y - 15 * scale,
                x, y + 10 * scale
            );
            ctx.closePath();
        }

        function drawStar(ctx, x, y, size) {
            const spikes = 5;
            const outerRadius = size / 2;
            const innerRadius = size / 4;
            let rot = Math.PI / 2 * 3;
            const step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(x, y - outerRadius);

            for (let i = 0; i < spikes; i++) {
                // Внешний угол
                let sx = x + Math.cos(rot) * outerRadius;
                let sy = y + Math.sin(rot) * outerRadius;
                ctx.lineTo(sx, sy);
                rot += step;

                // Внутренний угол
                sx = x + Math.cos(rot) * innerRadius;
                sy = y + Math.sin(rot) * innerRadius;
                ctx.lineTo(sx, sy);
                rot += step;
            }
            ctx.lineTo(x, y - outerRadius);
            ctx.closePath();
        }

        function drawCircle(ctx, x, y, size) {
            ctx.beginPath();
            ctx.arc(x, y, size / 2, 0, Math.PI * 2);
            ctx.closePath();
        }

        // Рисование молекулы с секторами разных форм
        function drawSectorMolecule(ctx, molecule) {
            if (!molecule.shapes || molecule.shapes.length === 0) return;

            ctx.save();

            // Если только одна форма, рисуем просто
            if (molecule.shapes.length === 1) {
                const shape = molecule.shapes[0];
                const shapeType = shape.type;

                // Применяем деформацию
                ctx.translate(molecule.x, molecule.y);
                ctx.rotate(molecule.deformAngle);
                ctx.scale(molecule.stretchX, molecule.stretchY);
                ctx.translate(-molecule.x, -molecule.y);

                // Рисуем форму
                switch(shapeType) {
                    case 'triangle':
                        drawTriangle(ctx, molecule.x, molecule.y, molecule.size);
                        break;
                    case 'heart':
                        drawHeart(ctx, molecule.x, molecule.y, molecule.size);
                        break;
                    case 'star':
                        drawStar(ctx, molecule.x, molecule.y, molecule.size);
                        break;
                    default: // circle
                        drawCircle(ctx, molecule.x, molecule.y, molecule.size);
                }

                // Заливка - всегда рисуем
                ctx.fillStyle = molecule.fillColor || '#f5f5f5';
                ctx.fill();

                // Контур - всегда рисуем
                ctx.strokeStyle = molecule.edgeColor || '#1a1a1a';
                ctx.lineWidth = 2.5;
                ctx.stroke();

            } else {
                // Несколько форм - рисуем секторами
                let startAngle = 0;

                for (const shape of molecule.shapes) {
                    const angleSize = shape.weight * Math.PI * 2;
                    const midAngle = startAngle + angleSize / 2;

                    ctx.save();

                    // Создаем путь клипа для сектора
                    ctx.beginPath();
                    ctx.moveTo(molecule.x, molecule.y);
                    ctx.arc(molecule.x, molecule.y, molecule.size, startAngle, startAngle + angleSize);
                    ctx.closePath();
                    ctx.clip();

                    // Применяем деформацию
                    ctx.translate(molecule.x, molecule.y);
                    ctx.rotate(molecule.deformAngle);
                    ctx.scale(molecule.stretchX, molecule.stretchY);
                    ctx.translate(-molecule.x, -molecule.y);

                    // Рисуем форму в этом секторе
                    switch(shape.type) {
                        case 'triangle':
                            drawTriangle(ctx, molecule.x, molecule.y, molecule.size);
                            break;
                        case 'heart':
                            drawHeart(ctx, molecule.x, molecule.y, molecule.size);
                            break;
                        case 'star':
                            drawStar(ctx, molecule.x, molecule.y, molecule.size);
                            break;
                        default: // circle
                            drawCircle(ctx, molecule.x, molecule.y, molecule.size);
                    }

                    // Заливка - всегда рисуем
                    ctx.fillStyle = molecule.fillColor || '#f5f5f5';
                    ctx.fill();

                    // Контур - всегда рисуем
                    ctx.strokeStyle = molecule.edgeColor || '#1a1a1a';
                    ctx.lineWidth = 2.5;
                    ctx.stroke();

                    ctx.restore();

                    startAngle += angleSize;
                }

                // Рисуем линии разделения секторов
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 2;
                startAngle = 0;
                for (const shape of molecule.shapes) {
                    const angleSize = shape.weight * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(molecule.x, molecule.y);
                    ctx.lineTo(
                        molecule.x + Math.cos(startAngle) * molecule.size,
                        molecule.y + Math.sin(startAngle) * molecule.size
                    );
                    ctx.stroke();
                    startAngle += angleSize;
                }
            }

            ctx.restore();
        }

        // Класс молекулы (метабол)
        class Molecule {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.baseSize = size;
                this.size = size;
                this.targetSize = size;  // Целевой размер для плавного изменения
                this.vx = 0;
                this.vy = 0;
                this.targetX = x;
                this.targetY = y;

                // Деформация от рук
                this.stretchX = 1;
                this.stretchY = 1;

                // Угол деформации (для растяжения под углом)
                this.deformAngle = 0;

                // Кеширование тригонометрии для производительности
                this._cachedCos = 1; // cos(0)
                this._cachedSin = 0; // sin(0)
                this._lastCachedAngle = 0;

                // Для визуализации - позиции рук в режиме редактирования
                this.editingHands = null; // { hand1: {x, y}, hand2: {x, y} }

                // Для звуковых эффектов
                this.audioPhase = Math.random() * Math.PI * 2;
                this.creationAudioLevel = audioLevel;

                // Состояние захвата
                this.isGrabbed = false;
                this.isLocked = false; // Зафиксирована позиция
                this.isShapeLocked = false; // Зафиксирована форма (растяжение)
                this.isEditing = false; // Режим редактирования

                // Цвета для Paint редактора (раздельные)
                this.fillColor = null; // Цвет заливки внутренности
                this.edgeColor = null; // Цвет заливки контура (пиксельный эффект)
                this.emboss = false; // Эффект тиснения (bevel & emboss)
                this.microStripes = false; // Эффект микро-градиентных полосок
                this.stripeColor1 = '#ff0000'; // Цвет 1 для градиента полосок
                this.stripeColor2 = '#0000ff'; // Цвет 2 для градиента полосок
                this.stripeWidth = 2; // Ширина полосок
                this.stripeSpacing = 3; // Расстояние между полосками

                // Кеш градиентов для производительности
                this._gradientCache = null;
                this._gradientCacheKey = null;

                // Стабилизация формы - счетчик кадров с двумя руками
                this.twoHandsFrameCount = 0; // Сколько кадров подряд видим 2 руки
                this.STABLE_HANDS_THRESHOLD = 5; // Нужно 5 кадров стабильности для изменения формы

                // Формы молекулы - массив объектов {type: string, weight: number}
                // weight показывает долю этой формы (сумма всех weight должна быть 1)
                this.shapes = [{type: 'circle', weight: 1}]; // По умолчанию круг
            }

            update() {
                // Плавное движение к цели (если не заблокирована)
                if (!this.isLocked) {
                    this.x += (this.targetX - this.x) * 0.1;
                    this.y += (this.targetY - this.y) * 0.1;
                    // Плавное изменение размера (только если не заблокирована)
                    this.size += (this.targetSize - this.size) * 0.1;
                }

                // Плавная деформация (если форма не заблокирована)
                // УПРОЩЕНО: прямое изменение без targetStretch для быстрого отклика
                if (!this.isShapeLocked) {
                    // Деформация применяется напрямую в режиме редактирования
                }

                // Обновляем фазу для звука
                this.audioPhase += 0.05;

                // Если молекула заблокирована - не реагируем на жесты
                if (this.isLocked) {
                    this.isGrabbed = false;
                    return;
                }

                // Фильтруем руки
                let openHands = hands.filter(h => h.isOpen && !h.isPinching && !h.isFist);

                if (this.isEditing) {
                    // РЕЖИМ РЕДАКТИРОВАНИЯ - управление двумя руками
                    if (openHands.length === 2) {
                        // Увеличиваем счетчик стабильности
                        this.twoHandsFrameCount++;

                        // ВАЖНО: Используем сырые данные рук для угла и растяжения (без сглаживания)
                        // Сглаживание только для позиции центра молекулы
                        const rawHand1 = openHands[0];
                        const rawHand2 = openHands[1];

                        this.isGrabbed = true;

                        // Сохраняем позиции рук для визуализации
                        this.editingHands = {
                            hand1: { x: rawHand1.x, y: rawHand1.y },
                            hand2: { x: rawHand2.x, y: rawHand2.y }
                        };

                        // === ДЕФОРМАЦИЯ: меняем форму только если руки стабильны ===
                        // Это предотвращает случайное изменение формы при редактировании размера
                        if (this.twoHandsFrameCount >= this.STABLE_HANDS_THRESHOLD) {
                            // Вектор между руками
                            const handsVecX = rawHand2.x - rawHand1.x;
                            const handsVecY = rawHand2.y - rawHand1.y;
                            const handsDist = Math.sqrt(handsVecX * handsVecX + handsVecY * handsVecY);

                            // УГОЛ: прямо от положения рук, мгновенный отклик
                            this.deformAngle = Math.atan2(handsVecY, handsVecX);

                            // РАСТЯЖЕНИЕ ВДОЛЬ ОСИ РУК (X в повёрнутой системе координат)
                            // Прямая пропорция: handsDist / baseSize
                            const baseStretch = handsDist / this.size;
                            this.stretchX = Math.max(0.2, Math.min(5.0, baseStretch));

                            // СЖАТИЕ ПОПЕРЁК (Y в повёрнутой системе координат)
                            // Когда растягиваем вдоль - сжимаем поперёк (как резинка)
                            if (this.stretchX > 1.2) {
                                // Если растянута - сжимаем поперёк
                                this.stretchY = Math.max(0.3, 1.0 / Math.sqrt(this.stretchX));
                            } else if (this.stretchX < 0.8) {
                                // Если сжата вдоль - растягиваем поперёк
                                this.stretchY = Math.min(2.5, 1.0 / Math.sqrt(this.stretchX));
                            } else {
                                // Близко к 1.0 - почти круглая
                                this.stretchY = 1.0;
                            }
                        }
                        // Если руки ещё не стабильны - форма не меняется, сохраняется как есть

                        // === ПОЗИЦИЯ И РАЗМЕР: можем сгладить для плавности ===

                        // Применяем лёгкое сглаживание только к позициям (не к углу!)
                        const smoothedHands = smoothHandPositions(openHands);
                        const hand1 = smoothedHands[0];
                        const hand2 = smoothedHands[1];

                        // Центр между двумя руками (сглаженный для плавного движения)
                        const centerX = (hand1.x + hand2.x) / 2;
                        const centerY = (hand1.y + hand2.y) / 2;

                        this.targetX = centerX;
                        this.targetY = centerY;

                        // УПРАВЛЕНИЕ РАЗМЕРОМ - средняя ширина ладоней
                        const avgHandWidth = (hand1.handWidth + hand2.handWidth) / 2;
                        // Адаптивный множитель в зависимости от размера экрана
                        const sizeMultiplier = maxMoleculeSize * 2.5; // ~750 для десктопа, ~300 для смартфонов
                        const newSize = Math.max(minMoleculeSize, Math.min(maxMoleculeSize * 2, avgHandWidth * sizeMultiplier));
                        this.targetSize = newSize;
                    } else if (openHands.length === 1) {
                        // Сбрасываем счетчик если видим одну руку
                        this.twoHandsFrameCount = 0;
                        // Одна рука - только перемещение и размер
                        const hand = openHands[0];
                        const dist = Math.sqrt((this.x - hand.x) ** 2 + (this.y - hand.y) ** 2);

                        if (dist < 150) {
                            this.isGrabbed = true;
                            this.targetX = hand.x;
                            this.targetY = hand.y;

                            // Ширина раскрытия ладони определяет размер (адаптивно под экран)
                            const sizeMultiplier = maxMoleculeSize * 2.5; // ~750 для десктопа, ~300 для смартфонов
                            const newSize = Math.max(minMoleculeSize, Math.min(maxMoleculeSize * 2, hand.handWidth * sizeMultiplier));
                            this.targetSize = newSize;

                            // Форма не меняется одной рукой
                            this.editingHands = null;
                        } else {
                            this.isGrabbed = false;
                            this.editingHands = null;
                        }
                    } else {
                        // Сбрасываем счетчик если рук нет или не видим нужное количество
                        this.twoHandsFrameCount = 0;
                        this.isGrabbed = false;
                        this.editingHands = null;
                    }
                } else if (!this.isEditing && openHands.length === 1) {
                    // ОБЫЧНЫЙ РЕЖИМ - только перемещение ладонью (форма сохраняется!)
                    const hand = openHands[0];
                    const dist = Math.sqrt((this.x - hand.x) ** 2 + (this.y - hand.y) ** 2);

                    if (dist < 120) {
                        this.isGrabbed = true;
                        this.targetX = hand.x;
                        this.targetY = hand.y;
                        // ИСПРАВЛЕНО: Форма НЕ сбрасывается, сохраняется как есть
                    } else {
                        this.isGrabbed = false;
                    }
                } else {
                    // Нет подходящих рук - отпускаем
                    this.isGrabbed = false;
                }

                // Границы экрана
                // УЛУЧШЕНО: Минимальный margin = размер молекулы, чтобы можно было подходить вплотную к краям
                // Это позволяет создавать молекулы у самого края экрана без "отмагничивания"
                const margin = this.size;  // Было: Math.min(this.size * 1.5, 200)
                this.targetX = Math.max(margin, Math.min(width - margin, this.targetX));
                this.targetY = Math.max(margin, Math.min(height - margin, this.targetY));
            }

            // Заблокировать молекулу (для UI)
            lock() {
                this.isLocked = true;
                this.isShapeLocked = true;
            }

            // Разблокировать молекулу (для UI)
            unlock() {
                this.isLocked = false;
                this.isShapeLocked = false;
            }

            // Функция влияния для метаболлов с поддержкой форм, поворота и растяжения
            getInfluence(px, py) {
                // Добавляем звуковую модуляцию (только в режиме жестов)
                let audioMod = 1;
                if (config.audioEnabled && !editorMode) {
                    const dx = px - this.x;
                    const dy = py - this.y;
                    const angle = Math.atan2(dy, dx);
                    audioMod = 1 + Math.sin(angle * 3 + this.audioPhase) * audioLevel * config.audioSensitivity * 0.02;
                }

                const effectiveSize = this.size * audioMod;

                // ИСПРАВЛЕНО: Применяем деформацию ДО вычисления SDF
                // Это преобразует точку (px, py) в локальную систему координат молекулы
                let sampleX = px;
                let sampleY = py;

                if (this.deformAngle !== 0 || this.stretchX !== 1 || this.stretchY !== 1) {
                    // Обновляем кеш тригонометрии если угол изменился
                    if (this.deformAngle !== this._lastCachedAngle) {
                        this._cachedCos = Math.cos(-this.deformAngle);
                        this._cachedSin = Math.sin(-this.deformAngle);
                        this._lastCachedAngle = this.deformAngle;
                    }

                    // Смещаем к центру молекулы
                    const dx = px - this.x;
                    const dy = py - this.y;

                    // Поворачиваем в локальную систему координат
                    const rotatedX = dx * this._cachedCos - dy * this._cachedSin;
                    const rotatedY = dx * this._cachedSin + dy * this._cachedCos;

                    // Применяем ОБРАТНОЕ растяжение к координатам
                    // (делим на stretchX/Y чтобы сжать пространство обратно)
                    const unstretchedX = rotatedX / this.stretchX;
                    const unstretchedY = rotatedY / this.stretchY;

                    // Поворачиваем обратно в мировую систему координат
                    const cos = Math.cos(this.deformAngle);
                    const sin = Math.sin(this.deformAngle);
                    sampleX = this.x + unstretchedX * cos - unstretchedY * sin;
                    sampleY = this.y + unstretchedX * sin + unstretchedY * cos;
                }

                // Вычисляем SDF для каждой формы в молекуле (используем деформированные координаты)
                let combinedDist = Infinity;

                if (!this.shapes || this.shapes.length === 0) {
                    // Нет форм - используем круг по умолчанию
                    combinedDist = sdfCircle(sampleX, sampleY, this.x, this.y, effectiveSize);
                } else if (this.shapes.length === 1) {
                    // Одна форма
                    const shape = this.shapes[0];
                    switch(shape.type) {
                        case 'triangle':
                            combinedDist = sdfTriangle(sampleX, sampleY, this.x, this.y, effectiveSize);
                            break;
                        case 'heart':
                            combinedDist = sdfHeart(sampleX, sampleY, this.x, this.y, effectiveSize);
                            break;
                        case 'star':
                            combinedDist = sdfStar(sampleX, sampleY, this.x, this.y, effectiveSize);
                            break;
                        default: // circle
                            combinedDist = sdfCircle(sampleX, sampleY, this.x, this.y, effectiveSize);
                    }
                } else {
                    // Несколько форм - смешиваем SDF (smooth minimum)
                    const k = 0.3; // Плавность смешивания
                    let totalWeight = 0;
                    let sumWeightedDist = 0;

                    for (const shape of this.shapes) {
                        let dist;
                        switch(shape.type) {
                            case 'triangle':
                                dist = sdfTriangle(sampleX, sampleY, this.x, this.y, effectiveSize);
                                break;
                            case 'heart':
                                dist = sdfHeart(sampleX, sampleY, this.x, this.y, effectiveSize);
                                break;
                            case 'star':
                                dist = sdfStar(sampleX, sampleY, this.x, this.y, effectiveSize);
                                break;
                            default: // circle
                                dist = sdfCircle(sampleX, sampleY, this.x, this.y, effectiveSize);
                        }

                        // Smooth minimum для плавного смешивания форм
                        const h = Math.max(k - Math.abs(dist - combinedDist), 0) / k;
                        const weight = shape.weight * (1 - h * h * h * 0.5);
                        sumWeightedDist += dist * weight;
                        totalWeight += weight;
                    }

                    combinedDist = totalWeight > 0 ? sumWeightedDist / totalWeight : Infinity;
                }

                // mergeStrength увеличивает радиус влияния
                const effectiveRadius = effectiveSize * Math.sqrt(config.mergeStrength);

                // Быстрая проверка - если точка слишком далеко, влияния нет
                if (combinedDist > effectiveRadius * 2) return 0;

                // Преобразуем расстояние в влияние (0 на границе, 1 в центре)
                const influence = Math.max(0, 1 - combinedDist / effectiveRadius);
                return influence * influence; // Квадратичное убывание для плавности
            }
        }

        // === СИСТЕМА СЛИЯНИЯ МОЛЕКУЛ ===

        // Проверяет, должны ли две молекулы слиться
        function shouldMergeMolecules(mol1, mol2) {
            // Не сливаем заблокированные или редактируемые молекулы
            if (mol1.isLocked || mol2.isLocked) return false;
            if (mol1.isEditing || mol2.isEditing) return false;

            // Расстояние между центрами
            const dx = mol2.x - mol1.x;
            const dy = mol2.y - mol1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Порог слияния: сумма размеров × 0.3
            // СТРОГИЙ ПОРОГ: молекулы должны быть ОЧЕНЬ близко, почти полностью перекрываться
            // При 0.3 центры молекул должны быть на расстоянии < 30% от суммы размеров
            // Например, две молекулы по 100px: расстояние должно быть < 60px для слияния
            const mergeThreshold = (mol1.size + mol2.size) * 0.3;

            // Базовая проверка расстояния
            if (distance >= mergeThreshold) return false;

            // === ЗАЩИТА ОТ СЛИЯНИЯ КРЕСТООБРАЗНЫХ ФОРМ ===
            // Если молекулы вытянуты и ориентированы перпендикулярно (как в крестике),
            // они НЕ должны сливаться, даже если центры близко

            const isStretched1 = mol1.stretchX > 1.5; // Молекула 1 вытянута
            const isStretched2 = mol2.stretchX > 1.5; // Молекула 2 вытянута

            // Если хотя бы одна молекула сильно вытянута
            if (isStretched1 || isStretched2) {
                // Вычисляем разницу углов
                let angleDiff = Math.abs(mol1.deformAngle - mol2.deformAngle);

                // Нормализуем разницу углов в диапазон [0, π]
                while (angleDiff > Math.PI) angleDiff -= Math.PI;
                if (angleDiff > Math.PI / 2) angleDiff = Math.PI - angleDiff;

                // Если углы отличаются на ~90° (± 30°), это крест - НЕ сливаем
                const isPerpendicular = Math.abs(angleDiff - Math.PI / 2) < Math.PI / 6; // ±30°

                if (isPerpendicular) {
                    return false; // Крестообразная форма - сохраняем обе молекулы
                }

                // Также НЕ сливаем если углы почти одинаковые (~0° или ~180°)
                // но молекулы вытянуты слабо в перпендикулярном направлении
                // (это может быть параллельные линии)
                const isParallel = angleDiff < Math.PI / 6; // ±30°
                const isAntiParallel = Math.abs(angleDiff - Math.PI) < Math.PI / 6;

                if (isParallel || isAntiParallel) {
                    // Параллельные вытянутые молекулы могут сливаться
                    // (это естественное поведение)
                    return true;
                }
            }

            // Если молекулы не вытянуты или ориентированы одинаково - сливаем как обычно
            return true;
        }

        // Сливает две молекулы в одну новую
        // Смешивание цветов RGB с весами
        function blendColors(color1, color2, weight1, weight2) {
            if (!color1 && !color2) return null;
            if (!color1) return color2;
            if (!color2) return color1;

            // Парсим цвета из HEX в RGB
            const parseColor = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            };

            const c1 = parseColor(color1);
            const c2 = parseColor(color2);

            // Взвешенное смешивание RGB
            const r = Math.round(c1.r * weight1 + c2.r * weight2);
            const g = Math.round(c1.g * weight1 + c2.g * weight2);
            const b = Math.round(c1.b * weight1 + c2.b * weight2);

            // Обратно в HEX
            const toHex = (n) => {
                const hex = n.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };

            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function mergeMolecules(mol1, mol2) {
            // Вычисляем веса на основе площади (size²)
            const area1 = mol1.size * mol1.size;
            const area2 = mol2.size * mol2.size;
            const totalArea = area1 + area2;
            const weight1 = area1 / totalArea;
            const weight2 = area2 / totalArea;

            // ПОЗИЦИЯ: Взвешенный центр масс
            const newX = mol1.x * weight1 + mol2.x * weight2;
            const newY = mol1.y * weight1 + mol2.y * weight2;

            // РАЗМЕР: Сохраняем общую площадь
            // newArea = area1 + area2
            // newSize² = size1² + size2²
            const newSize = Math.sqrt(area1 + area2);

            // Создаём новую молекулу
            const merged = new Molecule(newX, newY, newSize);

            // ФОРМА: Взвешенное среднее деформаций
            // Большая молекула имеет большее влияние на форму
            merged.stretchX = mol1.stretchX * weight1 + mol2.stretchX * weight2;
            merged.stretchY = mol1.stretchY * weight1 + mol2.stretchY * weight2;

            // УГОЛ: Усредняем углы (учитываем периодичность)
            // Переводим углы в векторы, усредняем, переводим обратно
            const angle1X = Math.cos(mol1.deformAngle);
            const angle1Y = Math.sin(mol1.deformAngle);
            const angle2X = Math.cos(mol2.deformAngle);
            const angle2Y = Math.sin(mol2.deformAngle);

            const avgAngleX = angle1X * weight1 + angle2X * weight2;
            const avgAngleY = angle1Y * weight1 + angle2Y * weight2;
            merged.deformAngle = Math.atan2(avgAngleY, avgAngleX);

            // СКОРОСТЬ: Усредняем (сохранение импульса)
            merged.vx = mol1.vx * weight1 + mol2.vx * weight2;
            merged.vy = mol1.vy * weight1 + mol2.vy * weight2;
            merged.targetX = newX;
            merged.targetY = newY;

            // ЗВУК: Усредняем фазу
            merged.audioPhase = (mol1.audioPhase + mol2.audioPhase) / 2;

            // ЦВЕТА: Смешиваем цвета взвешенно
            merged.fillColor = blendColors(mol1.fillColor, mol2.fillColor, weight1, weight2);
            merged.edgeColor = blendColors(mol1.edgeColor, mol2.edgeColor, weight1, weight2);

            // ЭФФЕКТЫ: Если хотя бы одна молекула имеет эффект - применяем к результату
            merged.emboss = mol1.emboss || mol2.emboss;

            // ФОРМЫ: Смешиваем формы с учетом весов
            const mergedShapes = [];
            const shapeMap = new Map();

            // Добавляем формы из первой молекулы
            if (mol1.shapes && mol1.shapes.length > 0) {
                for (const shape of mol1.shapes) {
                    const key = shape.type;
                    const weightedValue = shape.weight * weight1;
                    shapeMap.set(key, (shapeMap.get(key) || 0) + weightedValue);
                }
            }

            // Добавляем формы из второй молекулы
            if (mol2.shapes && mol2.shapes.length > 0) {
                for (const shape of mol2.shapes) {
                    const key = shape.type;
                    const weightedValue = shape.weight * weight2;
                    shapeMap.set(key, (shapeMap.get(key) || 0) + weightedValue);
                }
            }

            // Преобразуем обратно в массив и нормализуем веса
            let totalWeight = 0;
            for (const weight of shapeMap.values()) {
                totalWeight += weight;
            }

            for (const [type, weight] of shapeMap.entries()) {
                mergedShapes.push({
                    type: type,
                    weight: weight / totalWeight
                });
            }

            // Сортируем по весу (от большего к меньшему) для стабильного отображения
            mergedShapes.sort((a, b) => b.weight - a.weight);

            merged.shapes = mergedShapes.length > 0 ? mergedShapes : [{type: 'circle', weight: 1}];

            return merged;
        }

        // Проверяет и выполняет слияния молекул
        function checkAndMergeMolecules() {
            let merged = false;

            // Проходим по всем парам молекул
            for (let i = 0; i < molecules.length; i++) {
                for (let j = i + 1; j < molecules.length; j++) {
                    const mol1 = molecules[i];
                    const mol2 = molecules[j];

                    if (shouldMergeMolecules(mol1, mol2)) {
                        // Создаём новую объединённую молекулу
                        const newMolecule = mergeMolecules(mol1, mol2);

                        // Удаляем старые молекулы
                        molecules.splice(j, 1); // Удаляем j сначала (больший индекс)
                        molecules.splice(i, 1); // Потом i

                        // Добавляем новую
                        molecules.push(newMolecule);

                        // Обновляем ссылки на молекулы если они были hovered
                        if (hoveredMolecule === mol1 || hoveredMolecule === mol2) {
                            hoveredMolecule = newMolecule;
                        }
                        if (lastHoveredMolecule === mol1 || lastHoveredMolecule === mol2) {
                            lastHoveredMolecule = newMolecule;
                        }
                        // Примечание: editingMolecule не обновляем, т.к. редактируемые молекулы
                        // не могут сливаться (см. shouldMergeMolecules)

                        saveState(); // Сохраняем состояние для отмены

                        merged = true;
                        break;
                    }
                }
                if (merged) break; // Выходим из внешнего цикла
            }

            // Если произошло слияние, проверяем ещё раз (могут быть цепные слияния)
            if (merged) {
                checkAndMergeMolecules();
            }
        }

        // Инициализация аудио
        async function setupAudio() {
            console.log('Начинаем инициализацию аудио...');
            try {
                console.log('Запрашиваем доступ к микрофону...');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log('Доступ к микрофону получен!', stream);

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);

                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                microphone.connect(analyser);

                // Создаем визуализацию
                const audioBars = document.getElementById('audioBars');
                for (let i = 0; i < 10; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'audio-bar';
                    audioBars.appendChild(bar);
                }

                console.log('Аудио инициализировано успешно');
                return true;
            } catch (error) {
                console.error('Ошибка доступа к микрофону:', error);
                console.error('Имя ошибки:', error.name);
                console.error('Сообщение:', error.message);
                return false;
            }
        }

        // Анализ аудио
        function analyzeAudio() {
            if (!analyser || !dataArray) return;

            analyser.getByteFrequencyData(dataArray);

            // Средний уровень
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            audioLevel = (sum / dataArray.length) / 255;

            // Обновляем визуализацию
            const bars = document.querySelectorAll('.audio-bar');
            bars.forEach((bar, i) => {
                const value = dataArray[i * Math.floor(dataArray.length / bars.length)] / 255;
                bar.style.height = `${value * 100}%`;
            });
        }

        // Функция для кеширования статического фона (цвет или изображение)
        function renderBackgroundToCache() {
            // Создаём OffscreenCanvas если ещё не создан или изменился размер
            if (!backgroundCache || backgroundCache.width !== width || backgroundCache.height !== height) {
                backgroundCache = new OffscreenCanvas(width, height);
                backgroundCacheCtx = backgroundCache.getContext('2d');
            }

            // Рендерим фон в кеш
            if (backgroundType === 'color') {
                backgroundCacheCtx.fillStyle = backgroundColor;
                backgroundCacheCtx.fillRect(0, 0, width, height);
            } else if (backgroundType === 'image' && backgroundImage) {
                const imgAspect = backgroundImage.width / backgroundImage.height;
                const canvasAspect = width / height;
                let drawWidth, drawHeight, offsetX, offsetY;

                if (imgAspect > canvasAspect) {
                    drawHeight = height;
                    drawWidth = height * imgAspect;
                    offsetX = (width - drawWidth) / 2;
                    offsetY = 0;
                } else {
                    drawWidth = width;
                    drawHeight = width / imgAspect;
                    offsetX = 0;
                    offsetY = (height - drawHeight) / 2;
                }

                backgroundCacheCtx.drawImage(backgroundImage, offsetX, offsetY, drawWidth, drawHeight);
            } else {
                // Белый фон по умолчанию
                backgroundCacheCtx.fillStyle = '#ffffff';
                backgroundCacheCtx.fillRect(0, 0, width, height);
            }

            backgroundCacheValid = true;
        }

        // Рисование метаболлов через marching squares
        function drawMetaballs() {
            // Теперь все молекулы используют метаболы (с поддержкой разных форм через SDF)
            const moleculesToDraw = molecules;

            // НУЛЕВОЙ СЛОЙ: Фон (рисуется только если НЕ включено "показать видео")
            // В режиме "показать видео" фон уже нарисован в animate() - это видео с камеры
            if (!config.showVideo) {
                if (backgroundType === 'transparent') {
                    // Прозрачный фон - ничего не рисуем (для экспорта PNG/SVG)
                    ctx.clearRect(0, 0, width, height);
                } else if (backgroundType === 'video' && backgroundImage) {
                    // Видео фон рендерим каждый кадр (не кешируем)
                    const vidAspect = backgroundImage.videoWidth / backgroundImage.videoHeight;
                    const canvasAspect = width / height;
                    let drawWidth, drawHeight, offsetX, offsetY;

                    if (vidAspect > canvasAspect) {
                        drawHeight = height;
                        drawWidth = height * vidAspect;
                        offsetX = (width - drawWidth) / 2;
                        offsetY = 0;
                    } else {
                        drawWidth = width;
                        drawHeight = width / vidAspect;
                        offsetX = 0;
                        offsetY = (height - drawHeight) / 2;
                    }

                    ctx.drawImage(backgroundImage, offsetX, offsetY, drawWidth, drawHeight);
                } else {
                    // Для статического фона используем кеш
                    if (!backgroundCacheValid) {
                        renderBackgroundToCache();
                    }
                    // Просто копируем закешированный фон
                    ctx.drawImage(backgroundCache, 0, 0);
                }
            }

            // Рисуем фоновые заливки (под молекулами и штрихами)
            for (const region of backgroundFills) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = region.width;
                tempCanvas.height = region.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(region.imageData, 0, 0);
                ctx.drawImage(tempCanvas, region.x, region.y);
            }

            if (moleculesToDraw.length === 0) {
                // Если нет молекул, рисуем только штрихи карандаша
                // Сначала рисуем залитые области (под штрихами)
                for (const region of filledRegions) {
                    // Создаем временный canvas для правильного рендеринга с прозрачностью
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = region.width;
                    tempCanvas.height = region.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(region.imageData, 0, 0);
                    ctx.drawImage(tempCanvas, region.x, region.y);
                }

                // Затем рисуем все завершенные штрихи
                for (const stroke of drawnStrokes) {
                    if (stroke.points.length < 2) continue;

                    ctx.strokeStyle = stroke.color;
                    ctx.lineWidth = stroke.width;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    // Рисуем штрих по сегментам, пропуская стертые точки
                    let isDrawingSegment = false;

                    for (let i = 0; i < stroke.points.length; i++) {
                        const point = stroke.points[i];

                        // Пропускаем стертые точки
                        if (point.erased) {
                            if (isDrawingSegment) {
                                // Заканчиваем текущий сегмент
                                ctx.stroke();
                                isDrawingSegment = false;
                            }
                            continue;
                        }

                        // Рисуем не стертые точки
                        if (!isDrawingSegment) {
                            // Начинаем новый сегмент
                            ctx.beginPath();
                            ctx.moveTo(point.x, point.y);
                            isDrawingSegment = true;
                        } else {
                            // Продолжаем текущий сегмент
                            ctx.lineTo(point.x, point.y);
                        }
                    }

                    // Завершаем последний сегмент
                    if (isDrawingSegment) {
                        ctx.stroke();
                    }
                }

                // Рисуем текущий рисуемый штрих
                if (currentStroke && currentStroke.points.length > 1) {
                    ctx.strokeStyle = currentStroke.color;
                    ctx.lineWidth = currentStroke.width;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    ctx.beginPath();
                    ctx.moveTo(currentStroke.points[0].x, currentStroke.points[0].y);
                    for (let i = 1; i < currentStroke.points.length; i++) {
                        ctx.lineTo(currentStroke.points[i].x, currentStroke.points[i].y);
                    }
                    ctx.stroke();
                }
                return;
            }

            // Строим пространственный хеш для оптимизации (для всех молекул)
            const spatialHashStartTime = performance.now();
            buildSpatialHash(moleculesToDraw);
            const spatialHashTime = performance.now() - spatialHashStartTime;

            // Создаем сетку значений потенциала И доминирующих молекул
            const cols = Math.ceil(width / gridResolution) + 1;
            const rows = Math.ceil(height / gridResolution) + 1;
            const field = [];
            const dominantMolecule = []; // Молекула с наибольшим влиянием в каждой точке

            // Вычисляем поле влияния и доминирующие молекулы
            for (let i = 0; i < rows; i++) {
                field[i] = [];
                dominantMolecule[i] = [];
                for (let j = 0; j < cols; j++) {
                    const x = j * gridResolution;
                    const y = i * gridResolution;
                    let sum = 0;
                    let maxInfluence = 0;
                    let dominantMol = null;

                    // Суммируем влияние только близких молекул (пространственная оптимизация)
                    const nearbyMolecules = getNearbyMolecules(x, y);
                    for (const mol of nearbyMolecules) {
                        const influence = mol.getInfluence(x, y);
                        sum += influence;

                        // Запоминаем молекулу с наибольшим влиянием
                        if (influence > maxInfluence) {
                            maxInfluence = influence;
                            dominantMol = mol;
                        }
                    }

                    field[i][j] = sum;
                    dominantMolecule[i][j] = dominantMol;
                }
            }

            // ИСПРАВЛЕНО: Threshold рассчитывается так, чтобы одиночная молекула
            // сохраняла постоянный размер, но при этом радиус влияния увеличивался
            // Формула: при mergeStrength=1 threshold=0.5, при mergeStrength=2 threshold=0.667
            // Это позволяет молекулам сливаться на большем расстоянии при высоком mergeStrength
            const threshold = config.mergeStrength / (1 + config.mergeStrength);

            // ПЕРВЫЙ СЛОЙ: Гладкая заливка внутренних областей
            // Проходим по всем пикселям сетки и заливаем внутренности гладко
            const fillResolution = currentFillResolution; // Шаг для заливки (пиксели, адаптивный)

            for (let py = 0; py < height; py += fillResolution) {
                for (let px = 0; px < width; px += fillResolution) {
                    // Вычисляем влияние в этой точке
                    let totalInfluence = 0;
                    let maxInfluence = 0;
                    let dominantMol = null;

                    // Используем пространственную оптимизацию
                    const nearbyMolecules = getNearbyMolecules(px, py);
                    for (const mol of nearbyMolecules) {
                        const influence = mol.getInfluence(px, py);
                        totalInfluence += influence;

                        if (influence > maxInfluence) {
                            maxInfluence = influence;
                            dominantMol = mol;
                        }
                    }

                    // Если точка внутри контура (влияние выше порога) и есть fillColor
                    if (totalInfluence >= threshold && dominantMol && dominantMol.fillColor) {
                        ctx.fillStyle = dominantMol.fillColor;
                        ctx.fillRect(px, py, fillResolution, fillResolution);
                    }
                }
            }

            // ВТОРОЙ СЛОЙ: Marching squares с блочным эффектом на контурах
            ctx.fillStyle = '#f5f5f5';
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2.5;

            for (let i = 0; i < rows - 1; i++) {
                for (let j = 0; j < cols - 1; j++) {
                    const x = j * gridResolution;
                    const y = i * gridResolution;

                    const tl = field[i][j] >= threshold ? 1 : 0;
                    const tr = field[i][j + 1] >= threshold ? 1 : 0;
                    const br = field[i + 1][j + 1] >= threshold ? 1 : 0;
                    const bl = field[i + 1][j] >= threshold ? 1 : 0;

                    const cellIndex = tl * 8 + tr * 4 + br * 2 + bl * 1;

                    if (cellIndex === 0 || cellIndex === 15) continue;

                    // Определяем цвет контура для этой ячейки (по доминирующей молекуле в центре)
                    const centerMol = dominantMolecule[i][j];
                    const cellEdgeColor = (centerMol && centerMol.edgeColor) ? centerMol.edgeColor : null;

                    // Рисуем ячейку с блочной заливкой контура
                    drawMarchingSquareCell(x, y, cellIndex, field, i, j, threshold, cellEdgeColor);
                }
            }

            // ТРЕТИЙ СЛОЙ: Эффект тиснения (Bevel & Emboss) - создание иллюзии рельефа
            // Рисуем смещенные светлые и темные контуры для эффекта выпуклости/вогнутости
            // ОТКЛЮЧЕНО в режиме низкой производительности для ускорения рендеринга

            // Сначала собираем все контурные линии для молекул с тиснением
            const embossContours = [];

            if (!isLowPerformanceMode) {

            for (let i = 0; i < rows - 1; i++) {
                for (let j = 0; j < cols - 1; j++) {
                    const x = j * gridResolution;
                    const y = i * gridResolution;

                    const tl = field[i][j] >= threshold ? 1 : 0;
                    const tr = field[i][j + 1] >= threshold ? 1 : 0;
                    const br = field[i + 1][j + 1] >= threshold ? 1 : 0;
                    const bl = field[i + 1][j] >= threshold ? 1 : 0;

                    const cellIndex = tl * 8 + tr * 4 + br * 2 + bl * 1;

                    if (cellIndex === 0 || cellIndex === 15) continue;

                    // Проверяем что молекула имеет эффект тиснения
                    const centerMol = dominantMolecule[i][j];
                    if (!centerMol || !centerMol.emboss) continue;

                    // Сохраняем информацию о контурных линиях
                    embossContours.push({ x, y, i, j, cellIndex, mol: centerMol });
                }
            }

            // Если есть контуры с тиснением - рисуем эффект
            if (embossContours.length > 0) {
                const size = gridResolution;
                const embossDistance = 7; // УСИЛЕНО: Расстояние смещения для эффекта глубины (было 3)
                const lightAngle = -135 * Math.PI / 180; // Угол света (сверху-слева)
                const offsetX = Math.cos(lightAngle) * embossDistance;
                const offsetY = Math.sin(lightAngle) * embossDistance;

                // Функция для получения цвета фона
                const getBgColor = () => {
                    if (backgroundType === 'color') {
                        return backgroundColor;
                    }
                    return '#f5f5f5'; // Дефолт
                };

                // Функция для осветления/затемнения цвета
                const adjustColor = (color, amount) => {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);

                    const newR = Math.max(0, Math.min(255, r + amount));
                    const newG = Math.max(0, Math.min(255, g + amount));
                    const newB = Math.max(0, Math.min(255, b + amount));

                    return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
                };

                // Линии для marching squares
                const lines = {
                    1: [[3, 2]], 2: [[1, 2]], 3: [[3, 1]],
                    4: [[0, 1]], 5: [[0, 3], [1, 2]], 6: [[0, 2]],
                    7: [[0, 3]], 8: [[0, 3]], 9: [[0, 2]],
                    10: [[0, 1], [3, 2]], 11: [[0, 1]], 12: [[3, 1]],
                    13: [[1, 2]], 14: [[3, 2]]
                };

                function getEdgePoint(edge, i, j) {
                    const tl = field[i][j];
                    const tr = field[i][j + 1];
                    const br = field[i + 1][j + 1];
                    const bl = field[i + 1][j];
                    let t = 0.5;

                    switch(edge) {
                        case 0: // Верх
                            t = (threshold - tl) / (tr - tl);
                            return { x: t * size, y: 0 };
                        case 1: // Право
                            t = (threshold - tr) / (br - tr);
                            return { x: size, y: t * size };
                        case 2: // Низ
                            t = (threshold - bl) / (br - bl);
                            return { x: t * size, y: size };
                        case 3: // Лево
                            t = (threshold - tl) / (bl - tl);
                            return { x: 0, y: t * size };
                    }
                }

                // Рисуем для каждого контура
                for (const contour of embossContours) {
                    const { x, y, i, j, cellIndex, mol } = contour;

                    if (!lines[cellIndex]) continue;

                    // Определяем базовый цвет (фон или заливка молекулы)
                    const baseColor = mol.fillColor || getBgColor();

                    // СВЕТЛЫЙ КОНТУР (смещен в сторону света)
                    ctx.strokeStyle = adjustColor(baseColor, 130); // УСИЛЕНО: Светлее (было 80)
                    ctx.lineWidth = 4.5; // УСИЛЕНО: Толще (было 2.5)
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.9)'; // УСИЛЕНО: Ярче тень (было 0.6)
                    ctx.shadowBlur = 6; // УСИЛЕНО: Мягче тень (было 3)

                    ctx.beginPath();
                    for (const [e1, e2] of lines[cellIndex]) {
                        const p1 = getEdgePoint(e1, i, j);
                        const p2 = getEdgePoint(e2, i, j);
                        ctx.moveTo(x + p1.x + offsetX, y + p1.y + offsetY);
                        ctx.lineTo(x + p2.x + offsetX, y + p2.y + offsetY);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // ТЕМНЫЙ КОНТУР (смещен противоположно свету)
                    ctx.strokeStyle = adjustColor(baseColor, -130); // УСИЛЕНО: Темнее (было -80)
                    ctx.lineWidth = 4.5; // УСИЛЕНО: Толще (было 2.5)
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.9)'; // УСИЛЕНО: Темнее тень (было 0.6)
                    ctx.shadowBlur = 6; // УСИЛЕНО: Мягче тень (было 3)

                    ctx.beginPath();
                    for (const [e1, e2] of lines[cellIndex]) {
                        const p1 = getEdgePoint(e1, i, j);
                        const p2 = getEdgePoint(e2, i, j);
                        ctx.moveTo(x + p1.x - offsetX, y + p1.y - offsetY);
                        ctx.lineTo(x + p2.x - offsetX, y + p2.y - offsetY);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }
            } // Конец блока if (!isLowPerformanceMode) для эффекта тиснения

            // ЧЕТВЕРТЫЙ СЛОЙ: Микро-градиентные полоски для текстуры
            // Заполняем всю площадь молекулы вертикальными градиентными полосками
            // ОТКЛЮЧЕНО в режиме низкой производительности для ускорения рендеринга

            // Собираем молекулы с микрополосками
            const moleculesWithStripes = !isLowPerformanceMode ? molecules.filter(mol => mol.microStripes) : [];

            if (moleculesWithStripes.length > 0) {
                for (const mol of moleculesWithStripes) {
                    // Используем настройки из объекта молекулы
                    const stripeWidth = mol.stripeWidth || 2;
                    const stripeSpacing = mol.stripeSpacing || 3;
                    const color1 = mol.stripeColor1 || '#ff0000';
                    const color2 = mol.stripeColor2 || '#0000ff';

                    // Определяем bounding box молекулы
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;

                    // Находим границы молекулы по полю
                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            if (dominantMolecule[i][j] === mol && field[i][j] >= threshold) {
                                const x = j * gridResolution;
                                const y = i * gridResolution;
                                minX = Math.min(minX, x);
                                maxX = Math.max(maxX, x);
                                minY = Math.min(minY, y);
                                maxY = Math.max(maxY, y);
                            }
                        }
                    }

                    if (minX === Infinity) continue;

                    // Кешируем вычисление цветов для остановок градиента
                    const cacheKey = `${color1}_${color2}`;
                    let colorStops;

                    if (mol._gradientCacheKey === cacheKey && mol._gradientCache) {
                        // Используем кешированные цвета
                        colorStops = mol._gradientCache;
                    } else {
                        // Вычисляем цвета для остановок
                        const r1 = parseInt(color1.slice(1, 3), 16);
                        const g1 = parseInt(color1.slice(3, 5), 16);
                        const b1 = parseInt(color1.slice(5, 7), 16);

                        const r2 = parseInt(color2.slice(1, 3), 16);
                        const g2 = parseInt(color2.slice(3, 5), 16);
                        const b2 = parseInt(color2.slice(5, 7), 16);

                        // Предвычисляем все цвета для остановок
                        const numStops = 10;
                        colorStops = [];
                        for (let i = 0; i <= numStops; i++) {
                            const t = i / numStops;
                            const baseR = r1 + (r2 - r1) * t;
                            const baseG = g1 + (g2 - g1) * t;
                            const baseB = b1 + (b2 - b1) * t;
                            colorStops.push({ t, baseR, baseG, baseB });
                        }

                        // Сохраняем в кеш
                        mol._gradientCache = colorStops;
                        mol._gradientCacheKey = cacheKey;
                    }

                    // Создаем маску для молекулы
                    ctx.save();
                    ctx.beginPath();

                    // Обводим контур молекулы для маски
                    for (let i = 0; i < rows - 1; i++) {
                        for (let j = 0; j < cols - 1; j++) {
                            if (dominantMolecule[i][j] !== mol) continue;

                            const x = j * gridResolution;
                            const y = i * gridResolution;

                            const tl = field[i][j] >= threshold ? 1 : 0;
                            const tr = field[i][j + 1] >= threshold ? 1 : 0;
                            const br = field[i + 1][j + 1] >= threshold ? 1 : 0;
                            const bl = field[i + 1][j] >= threshold ? 1 : 0;

                            // Простая заливка области молекулы
                            if (tl || tr || br || bl) {
                                ctx.rect(x, y, gridResolution, gridResolution);
                            }
                        }
                    }

                    ctx.clip(); // Ограничиваем рисование областью молекулы

                    // Рисуем вертикальные полоски с градиентом
                    for (let x = minX - stripeSpacing; x <= maxX + stripeSpacing; x += stripeSpacing) {
                        // Создаем градиент для каждой полоски от color1 к color2
                        const gradient = ctx.createLinearGradient(x, minY, x, maxY);

                        // Используем закешированные цвета остановок
                        for (const stop of colorStops) {
                            // Добавляем небольшие вариации для текстуры
                            const variation = (Math.sin(x * 0.1 + stop.t * Math.PI * 4) * 0.5 + 0.5) * 20 - 10;

                            const newR = Math.max(0, Math.min(255, stop.baseR + variation));
                            const newG = Math.max(0, Math.min(255, stop.baseG + variation));
                            const newB = Math.max(0, Math.min(255, stop.baseB + variation));

                            gradient.addColorStop(stop.t, `rgb(${newR}, ${newG}, ${newB})`);
                        }

                        ctx.fillStyle = gradient;
                        ctx.fillRect(x, minY, stripeWidth, maxY - minY);
                    }

                    ctx.restore();
                }
            }

            // ПЯТЫЙ СЛОЙ: Подсветка молекулы при наведении в режиме редактора
            if (editorMode && hoveredMoleculeEditor && (currentTool === 'fill' || currentTool === 'eraser')) {
                const mol = hoveredMoleculeEditor;

                // Рисуем подсветку по контуру молекулы
                ctx.save();
                ctx.translate(mol.x, mol.y);
                ctx.rotate(mol.deformAngle);

                // Полупрозрачная подсветка
                ctx.strokeStyle = currentTool === 'fill' ? 'rgba(0, 150, 255, 0.8)' : 'rgba(255, 100, 100, 0.8)';
                ctx.lineWidth = 4;
                ctx.setLineDash([10, 5]);

                // Рисуем эллипс подсветки
                ctx.beginPath();
                ctx.ellipse(0, 0, mol.size * mol.stretchX, mol.size * mol.stretchY, 0, 0, Math.PI * 2);
                ctx.stroke();

                ctx.setLineDash([]);
                ctx.restore();

                // Подсказка о режиме заливки
                if (currentTool === 'fill') {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.font = '14px Arial';
                    const hint = fillMode === 'interior' ? 'Interior' :
                                 fillMode === 'edge' ? 'Edge' : 'Both';
                    const metrics = ctx.measureText(hint);
                    ctx.fillText(hint, mol.x - metrics.width / 2, mol.y - mol.size - 10);
                }
            }

            // ШЕСТОЙ СЛОЙ: Отрисовка штрихов карандаша (поверх всех молекул)
            // Сначала рисуем залитые области (под штрихами)
            for (const region of filledRegions) {
                // Создаем временный canvas для правильного рендеринга с прозрачностью
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = region.width;
                tempCanvas.height = region.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(region.imageData, 0, 0);
                ctx.drawImage(tempCanvas, region.x, region.y);
            }

            // Затем рисуем все завершенные штрихи
            for (const stroke of drawnStrokes) {
                if (stroke.points.length < 2) continue;

                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = stroke.width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Рисуем штрих по сегментам, пропуская стертые точки
                let isDrawing = false;

                for (let i = 0; i < stroke.points.length; i++) {
                    const point = stroke.points[i];

                    // Пропускаем стертые точки
                    if (point.erased) {
                        if (isDrawing) {
                            // Заканчиваем текущий сегмент
                            ctx.stroke();
                            isDrawing = false;
                        }
                        continue;
                    }

                    // Рисуем не стертые точки
                    if (!isDrawing) {
                        // Начинаем новый сегмент
                        ctx.beginPath();
                        ctx.moveTo(point.x, point.y);
                        isDrawing = true;
                    } else {
                        // Продолжаем текущий сегмент
                        ctx.lineTo(point.x, point.y);
                    }
                }

                // Завершаем последний сегмент
                if (isDrawing) {
                    ctx.stroke();
                }
            }

            // Рисуем текущий рисуемый штрих
            if (currentStroke && currentStroke.points.length > 1) {
                ctx.strokeStyle = currentStroke.color;
                ctx.lineWidth = currentStroke.width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                ctx.beginPath();
                ctx.moveTo(currentStroke.points[0].x, currentStroke.points[0].y);
                for (let i = 1; i < currentStroke.points.length; i++) {
                    ctx.lineTo(currentStroke.points[i].x, currentStroke.points[i].y);
                }
                ctx.stroke();
            }
        }

        // Отрисовка одной ячейки marching squares
        function drawMarchingSquareCell(x, y, cellIndex, field, i, j, threshold, edgeColor) {
            const size = gridResolution;

            // Интерполяция позиций на гранях
            function lerp(v0, v1, t) {
                return v0 + t * (v1 - v0);
            }

            function getEdgePoint(edge) {
                const tl = field[i][j];
                const tr = field[i][j + 1];
                const br = field[i + 1][j + 1];
                const bl = field[i + 1][j];

                let t = 0.5; // По умолчанию середина

                switch(edge) {
                    case 0: // Верх
                        t = (threshold - tl) / (tr - tl);
                        return { x: lerp(x, x + size, t), y: y };
                    case 1: // Право
                        t = (threshold - tr) / (br - tr);
                        return { x: x + size, y: lerp(y, y + size, t) };
                    case 2: // Низ
                        t = (threshold - bl) / (br - bl);
                        return { x: lerp(x, x + size, t), y: y + size };
                    case 3: // Лево
                        t = (threshold - tl) / (bl - tl);
                        return { x: x, y: lerp(y, y + size, t) };
                }
            }

            // Линии для разных конфигураций marching squares
            const lines = {
                1: [[3, 2]], 2: [[1, 2]], 3: [[3, 1]],
                4: [[0, 1]], 5: [[0, 3], [1, 2]], 6: [[0, 2]],
                7: [[0, 3]], 8: [[0, 3]], 9: [[0, 2]],
                10: [[0, 1], [3, 2]], 11: [[0, 1]], 12: [[3, 1]],
                13: [[1, 2]], 14: [[3, 2]]
            };

            if (!lines[cellIndex]) return;

            // БЛОЧНЫЙ ЭФФЕКТ: Рисуем блочную заливку только на краевых ячейках
            // (те, что пересекаются контуром - 1-2 заполненных угла)
            // Это создаёт крутой пиксельный эффект на границах
            if (edgeColor) {
                const tl = field[i][j] >= threshold;
                const tr = field[i][j + 1] >= threshold;
                const br = field[i + 1][j + 1] >= threshold;
                const bl = field[i + 1][j] >= threshold;

                const filledCorners = [tl, tr, br, bl].filter(Boolean).length;

                // Блочный эффект только для частично заполненных ячеек (1-2 угла)
                // Это ячейки, которые пересекаются контуром
                if (filledCorners >= 1 && filledCorners <= 2) {
                    ctx.fillStyle = edgeColor;
                    ctx.fillRect(x, y, size, size);
                }
            }

            // Рисуем контур поверх
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            for (const [e1, e2] of lines[cellIndex]) {
                const p1 = getEdgePoint(e1);
                const p2 = getEdgePoint(e2);
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            }
            ctx.stroke();
        }

        // Сглаживание жестов - проверяем что жест стабилен в последних N кадрах
        function getStableGesture(handIndex, gestureName) {
            if (gestureHistory.length < GESTURE_HISTORY_SIZE) {
                return false; // Недостаточно истории
            }

            // Проверяем что в последних N кадрах жест был консистентным
            let consistentCount = 0;
            for (let i = 0; i < GESTURE_HISTORY_SIZE; i++) {
                const frame = gestureHistory[gestureHistory.length - 1 - i];
                if (frame && frame[handIndex] && frame[handIndex][gestureName]) {
                    consistentCount++;
                }
            }

            // Требуем минимум 4 из 5 кадров для стабильности
            return consistentCount >= 4;
        }

        // Проверка стабильного состояния для обеих рук (не привязываемся к индексу руки)
        function checkStableTwoHands(gestureName) {
            if (hands.length !== 2) return false;
            if (gestureHistory.length < 3) return false; // Уменьшаем требование

            // Проверяем что в последних 3 кадрах было ровно 2 руки с нужным жестом
            let consistentCount = 0;
            for (let i = 0; i < Math.min(3, gestureHistory.length); i++) {
                const frame = gestureHistory[gestureHistory.length - 1 - i];
                if (frame && frame.length === 2) {
                    // Считаем сколько рук имеют нужный жест в этом кадре
                    const handsWithGesture = frame.filter(h => h[gestureName]).length;
                    if (handsWithGesture === 2) {
                        consistentCount++;
                    }
                }
            }

            // Требуем минимум 2 из 3 последних кадров
            return consistentCount >= 2;
        }

        // Определение жестов
        function getPinchDistance(landmarks) {
            const thumb = landmarks[4];
            const index = landmarks[8];
            const dx = thumb.x - index.x;
            const dy = thumb.y - index.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // НОВОЕ: Улучшенная детекция щипка - проверяем pinch с любым пальцем (не только указательным)
        function isPinching(landmarks) {
            const thumbTip = landmarks[4];

            // Проверяем расстояние от большого пальца до каждого пальца
            const distances = {
                index: Math.sqrt((thumbTip.x - landmarks[8].x) ** 2 + (thumbTip.y - landmarks[8].y) ** 2),
                middle: Math.sqrt((thumbTip.x - landmarks[12].x) ** 2 + (thumbTip.y - landmarks[12].y) ** 2),
                ring: Math.sqrt((thumbTip.x - landmarks[16].x) ** 2 + (thumbTip.y - landmarks[16].y) ** 2),
                pinky: Math.sqrt((thumbTip.x - landmarks[20].x) ** 2 + (thumbTip.y - landmarks[20].y) ** 2)
            };

            // Находим минимальное расстояние (какой палец ближе всего к большому)
            const minDist = Math.min(distances.index, distances.middle, distances.ring, distances.pinky);

            // СМЯГЧЕНО: Pinch если палец достаточно близко к большому
            if (minDist >= 0.055) return false;  // Было 0.035, теперь мягче для стабильности

            // ВАЖНО: Проверяем что это не жест "все пальцы вместе"
            // При pinch хотя бы некоторые пальцы должны быть открыты
            const palmCenter = landmarks[9];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const indexTip = landmarks[8];

            // Расстояния пальцев от центра ладони
            const indexFromPalm = Math.sqrt(
                (indexTip.x - palmCenter.x) ** 2 +
                (indexTip.y - palmCenter.y) ** 2
            );
            const middleFromPalm = Math.sqrt(
                (middleTip.x - palmCenter.x) ** 2 +
                (middleTip.y - palmCenter.y) ** 2
            );
            const ringFromPalm = Math.sqrt(
                (ringTip.x - palmCenter.x) ** 2 +
                (ringTip.y - palmCenter.y) ** 2
            );
            const pinkyFromPalm = Math.sqrt(
                (pinkyTip.x - palmCenter.x) ** 2 +
                (pinkyTip.y - palmCenter.y) ** 2
            );

            // Считаем сколько пальцев открыты (СМЯГЧЕНО: уменьшен порог)
            let openFingersCount = 0;
            if (indexFromPalm > 0.08) openFingersCount++;
            if (middleFromPalm > 0.08) openFingersCount++;
            if (ringFromPalm > 0.08) openFingersCount++;
            if (pinkyFromPalm > 0.08) openFingersCount++;

            // СМЯГЧЕНО: Для щипка минимум 1 палец должен быть открыт (не "все пальцы вместе")
            return openFingersCount >= 1;
        }

        // НОВОЕ: Улучшенная детекция загнутых пальцев для режима редактирования
        function detectFoldedFingers(landmarks) {
            const palmCenter = landmarks[9];
            const palm = landmarks[0];

            // Для каждого пальца проверяем:
            // 1. Расстояние кончика от основания (прямая проверка сгиба)
            // 2. Расстояние кончика от центра ладони (относительная проверка)
            // 3. Комбинированное решение для точности

            // БОЛЬШОЙ ПАЛЕЦ
            const thumbTip = landmarks[4];
            const thumbBase = landmarks[2];
            const thumbLength = Math.sqrt(
                (thumbTip.x - thumbBase.x) ** 2 +
                (thumbTip.y - thumbBase.y) ** 2
            );
            const thumbToPalm = Math.sqrt(
                (thumbTip.x - palmCenter.x) ** 2 +
                (thumbTip.y - palmCenter.y) ** 2
            );
            const thumbFolded = thumbLength < 0.065 || thumbToPalm < 0.11;

            // УКАЗАТЕЛЬНЫЙ ПАЛЕЦ
            const indexTip = landmarks[8];
            const indexBase = landmarks[5];
            const indexMid = landmarks[6];
            const indexLength = Math.sqrt(
                (indexTip.x - indexBase.x) ** 2 +
                (indexTip.y - indexBase.y) ** 2
            );
            const indexToPalm = Math.sqrt(
                (indexTip.x - palmCenter.x) ** 2 +
                (indexTip.y - palmCenter.y) ** 2
            );
            // Проверяем угол сгиба через среднюю фалангу
            const indexBend = Math.sqrt(
                (indexTip.x - indexMid.x) ** 2 +
                (indexTip.y - indexMid.y) ** 2
            );
            const indexFolded = (indexLength < 0.09 && indexToPalm < 0.14) || indexBend < 0.05;

            // СРЕДНИЙ ПАЛЕЦ
            const middleTip = landmarks[12];
            const middleBase = landmarks[9];
            const middleMid = landmarks[10];
            const middleLength = Math.sqrt(
                (middleTip.x - middleBase.x) ** 2 +
                (middleTip.y - middleBase.y) ** 2
            );
            const middleToPalm = Math.sqrt(
                (middleTip.x - palmCenter.x) ** 2 +
                (middleTip.y - palmCenter.y) ** 2
            );
            const middleBend = Math.sqrt(
                (middleTip.x - middleMid.x) ** 2 +
                (middleTip.y - middleMid.y) ** 2
            );
            const middleFolded = (middleLength < 0.10 && middleToPalm < 0.14) || middleBend < 0.05;

            // БЕЗЫМЯННЫЙ ПАЛЕЦ
            const ringTip = landmarks[16];
            const ringBase = landmarks[13];
            const ringMid = landmarks[14];
            const ringLength = Math.sqrt(
                (ringTip.x - ringBase.x) ** 2 +
                (ringTip.y - ringBase.y) ** 2
            );
            const ringToPalm = Math.sqrt(
                (ringTip.x - palmCenter.x) ** 2 +
                (ringTip.y - palmCenter.y) ** 2
            );
            const ringBend = Math.sqrt(
                (ringTip.x - ringMid.x) ** 2 +
                (ringTip.y - ringMid.y) ** 2
            );
            const ringFolded = (ringLength < 0.09 && ringToPalm < 0.13) || ringBend < 0.05;

            // МИЗИНЕЦ
            const pinkyTip = landmarks[20];
            const pinkyBase = landmarks[17];
            const pinkyMid = landmarks[18];
            const pinkyLength = Math.sqrt(
                (pinkyTip.x - pinkyBase.x) ** 2 +
                (pinkyTip.y - pinkyBase.y) ** 2
            );
            const pinkyToPalm = Math.sqrt(
                (pinkyTip.x - palmCenter.x) ** 2 +
                (pinkyTip.y - palmCenter.y) ** 2
            );
            const pinkyBend = Math.sqrt(
                (pinkyTip.x - pinkyMid.x) ** 2 +
                (pinkyTip.y - pinkyMid.y) ** 2
            );
            const pinkyFolded = (pinkyLength < 0.07 && pinkyToPalm < 0.12) || pinkyBend < 0.04;

            return {
                thumb: thumbFolded,
                index: indexFolded,
                middle: middleFolded,
                ring: ringFolded,
                pinky: pinkyFolded
            };
        }

        function isHandOpen(landmarks) {
            // УЛУЧШЕНО: Более точная проверка открытой ладони
            const palm = landmarks[0];
            const palmCenter = landmarks[9];

            // Проверяем расстояния кончиков пальцев от центра ладони
            const fingerTips = [
                { tip: landmarks[8], base: landmarks[5], name: 'index' },    // Указательный
                { tip: landmarks[12], base: landmarks[9], name: 'middle' },  // Средний
                { tip: landmarks[16], base: landmarks[13], name: 'ring' },   // Безымянный
                { tip: landmarks[20], base: landmarks[17], name: 'pinky' }   // Мизинец
            ];

            let extendedCount = 0;
            fingerTips.forEach(finger => {
                // Проверяем что палец вытянут (кончик далеко от основания)
                const tipToBase = Math.sqrt(
                    (finger.tip.x - finger.base.x) ** 2 +
                    (finger.tip.y - finger.base.y) ** 2
                );

                // И палец далеко от центра ладони
                const tipToPalm = Math.sqrt(
                    (finger.tip.x - palmCenter.x) ** 2 +
                    (finger.tip.y - palmCenter.y) ** 2
                );

                // Палец считается открытым если он вытянут И далеко от ладони
                if (tipToBase > 0.07 && tipToPalm > 0.13) {
                    extendedCount++;
                }
            });

            // Проверяем большой палец отдельно
            const thumbTip = landmarks[4];
            const thumbBase = landmarks[2];
            const thumbExtended = Math.sqrt(
                (thumbTip.x - thumbBase.x) ** 2 +
                (thumbTip.y - thumbBase.y) ** 2
            ) > 0.06;

            // Ладонь открыта если минимум 3 пальца (не считая большой) вытянуты
            // ИЛИ все 4 пальца + большой вытянуты
            return extendedCount >= 3 || (extendedCount >= 2 && thumbExtended);
        }

        function isHandFist(landmarks) {
            // НОВАЯ ЛОГИКА: Щипок всеми пальцами (все кончики пальцев собраны вместе)
            // ВАЖНО: должен отличаться от обычного pinch

            // Кончики всех 5 пальцев
            const fingerTips = [
                landmarks[4],  // Большой
                landmarks[8],  // Указательный
                landmarks[12], // Средний
                landmarks[16], // Безымянный
                landmarks[20]  // Мизинец
            ];

            // Вычисляем центр всех кончиков пальцев
            let centerX = 0, centerY = 0;
            fingerTips.forEach(tip => {
                centerX += tip.x;
                centerY += tip.y;
            });
            centerX /= fingerTips.length;
            centerY /= fingerTips.length;

            // Проверяем что каждый кончик пальца близко к центру
            let maxDistanceFromCenter = 0;
            let fingersCloseCount = 0;
            const distances = [];

            fingerTips.forEach(tip => {
                const dist = Math.sqrt(
                    (tip.x - centerX) ** 2 +
                    (tip.y - centerY) ** 2
                );
                distances.push(dist);
                maxDistanceFromCenter = Math.max(maxDistanceFromCenter, dist);

                // Порог для "близко" - палец считается близким если в радиусе 0.06
                if (dist < 0.06) {
                    fingersCloseCount++;
                }
            });

            // КЛЮЧЕВОЕ ОТЛИЧИЕ ОТ PINCH: проверяем что это не просто два пальца вместе
            // При обычном pinch: два пальца очень близко, остальные далеко
            const thumbTip = landmarks[4];
            const pinchDistances = [
                Math.sqrt((thumbTip.x - landmarks[8].x) ** 2 + (thumbTip.y - landmarks[8].y) ** 2),
                Math.sqrt((thumbTip.x - landmarks[12].x) ** 2 + (thumbTip.y - landmarks[12].y) ** 2),
                Math.sqrt((thumbTip.x - landmarks[16].x) ** 2 + (thumbTip.y - landmarks[16].y) ** 2),
                Math.sqrt((thumbTip.x - landmarks[20].x) ** 2 + (thumbTip.y - landmarks[20].y) ** 2)
            ];

            // Считаем сколько пальцев далеко от большого
            let fingersAwayFromThumb = 0;
            pinchDistances.forEach(d => { if (d > 0.08) fingersAwayFromThumb++; });

            // Это обычный pinch если 1-2 пальца у большого, а 2-3 пальца далеко
            const minPinchDist = Math.min(...pinchDistances);
            const isPinchLike = fingersAwayFromThumb >= 2 && minPinchDist < 0.05;

            // Все пальцы собраны вместе если:
            // 1. Максимальное расстояние от центра < 0.09 (все пальцы в кучке)
            // 2. Минимум 3 из 5 пальцев близко к центру
            // 3. Это НЕ обычный pinch (не ситуация "два пальца вместе, остальные далеко")
            const allFingersTogether = maxDistanceFromCenter < 0.09 && fingersCloseCount >= 3 && !isPinchLike;

            const isFist = allFingersTogether;

            // ОТЛАДКА: временно включена
            if (fingersCloseCount >= 2) {
                console.log('🔍 All Fingers Together Debug:', {
                    maxDistFromCenter: maxDistanceFromCenter.toFixed(3),
                    fingersCloseCount: `${fingersCloseCount}/5`,
                    fingersAwayFromThumb: `${fingersAwayFromThumb}/4`,
                    minPinchDist: minPinchDist.toFixed(3),
                    isPinchLike,
                    isFist
                });
            }

            return isFist;
        }

        function isFingersCrossed(landmarks) {
            // УЛУЧШЕНО v5: Баланс между точностью и детектируемостью
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const palm = landmarks[0];
            const palmCenter = landmarks[9];
            const indexBase = landmarks[5];
            const middleBase = landmarks[9];

            // 1. КЛЮЧЕВОЙ КРИТЕРИЙ: Пальцы близко друг к другу
            const fingersDist = Math.sqrt(
                (indexTip.x - middleTip.x) ** 2 +
                (indexTip.y - middleTip.y) ** 2
            );

            // 2. Оба пальца вытянуты от ладони
            const indexFromPalm = Math.sqrt(
                (indexTip.x - palm.x) ** 2 +
                (indexTip.y - palm.y) ** 2
            );
            const middleFromPalm = Math.sqrt(
                (middleTip.x - palm.x) ** 2 +
                (middleTip.y - palm.y) ** 2
            );

            // 3. Проверяем что пальцы вытянуты
            const indexLength = Math.sqrt(
                (indexTip.x - indexBase.x) ** 2 +
                (indexTip.y - indexBase.y) ** 2
            );
            const middleLength = Math.sqrt(
                (middleTip.x - middleBase.x) ** 2 +
                (middleTip.y - middleBase.y) ** 2
            );

            // 4. Не щипок
            const thumbTip = landmarks[4];
            const thumbIndexDist = Math.sqrt(
                (thumbTip.x - indexTip.x) ** 2 +
                (thumbTip.y - indexTip.y) ** 2
            );

            // 5. Не жест "все пальцы вместе"
            const thumbToPalm = Math.sqrt(
                (thumbTip.x - palmCenter.x) ** 2 +
                (thumbTip.y - palmCenter.y) ** 2
            );

            // НОВОЕ: Проверка что оба пальца вытянуты ОДИНАКОВО (параллельны)
            // Это предотвращает ложные срабатывания когда один палец согнут
            const fingersEvenlyExtended = Math.abs(indexFromPalm - middleFromPalm) < 0.04;

            // СБАЛАНСИРОВАННЫЕ КРИТЕРИИ (золотая середина):
            const fingersClose = fingersDist < 0.035;             // БАЛАНС: между строгим (0.025) и мягким (0.055)
            const bothExtended = indexFromPalm > 0.14 &&          // БАЛАНС: между 0.12 и 0.15
                                middleFromPalm > 0.14;
            const bothLongEnough = indexLength > 0.075 &&         // БАЛАНС: между 0.07 и 0.08
                                  middleLength > 0.075;
            const notPinching = thumbIndexDist > 0.055;           // Чуть мягче для удобства
            const notFist = thumbToPalm > 0.085;                  // БАЛАНС: между 0.08 и 0.09

            return fingersClose &&
                   bothExtended &&
                   bothLongEnough &&
                   fingersEvenlyExtended &&  // НОВАЯ проверка!
                   notPinching &&
                   notFist;
        }

        // Детекция мизинца (только мизинец поднят)
        function isPinkyUp(landmarks) {
            const palm = landmarks[0];
            const palmCenter = landmarks[9];
            const pinkyTip = landmarks[20];
            const pinkyBase = landmarks[17];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const thumbTip = landmarks[4];

            // 1. Мизинец вытянут
            const pinkyExtended = Math.sqrt(
                (pinkyTip.x - pinkyBase.x) ** 2 +
                (pinkyTip.y - pinkyBase.y) ** 2
            ) > 0.05;

            // 2. Расстояния от ладони
            const pinkyFromPalm = Math.sqrt(
                (pinkyTip.x - palmCenter.x) ** 2 +
                (pinkyTip.y - palmCenter.y) ** 2
            );
            const indexFromPalm = Math.sqrt(
                (indexTip.x - palmCenter.x) ** 2 +
                (indexTip.y - palmCenter.y) ** 2
            );
            const middleFromPalm = Math.sqrt(
                (middleTip.x - palmCenter.x) ** 2 +
                (middleTip.y - palmCenter.y) ** 2
            );
            const ringFromPalm = Math.sqrt(
                (ringTip.x - palmCenter.x) ** 2 +
                (ringTip.y - palmCenter.y) ** 2
            );
            const thumbFromPalm = Math.sqrt(
                (thumbTip.x - palmCenter.x) ** 2 +
                (thumbTip.y - palmCenter.y) ** 2
            );

            // СБАЛАНСИРОВАНО v4: Золотая середина для детекции мизинца
            // 3. Мизинец вытянут и дальше от ладони чем остальные пальцы
            const pinkyFarthest = pinkyFromPalm > 0.10 &&                    // Вернули к 0.10
                                  pinkyFromPalm > indexFromPalm * 0.75 &&    // Золотая середина
                                  pinkyFromPalm > middleFromPalm * 0.75 &&
                                  pinkyFromPalm > ringFromPalm * 0.70;       // Чуть мягче для безымянного

            // 4. Другие пальцы относительно согнуты
            // УЖЕСТОЧЕНО: Все 3 пальца должны быть согнуты (не 2 из 3)
            const othersClosed = indexFromPalm < 0.15 &&
                                middleFromPalm < 0.15 &&
                                ringFromPalm < 0.14;

            // 5. Большой палец не сильно вытянут
            const thumbNotExtended = thumbFromPalm < 0.17;

            // 6. Не щипок
            const thumbIndexDist = Math.sqrt(
                (thumbTip.x - indexTip.x) ** 2 +
                (thumbTip.y - indexTip.y) ** 2
            );
            const notPinching = thumbIndexDist > 0.05;

            return pinkyExtended &&
                   pinkyFarthest &&
                   othersClosed &&
                   thumbNotExtended &&
                   notPinching;
        }

        // УЛУЧШЕНО: Проверка стабильности индивидуального жеста
        function isGestureStable(gestureName, currentValue) {
            const stability = GESTURE_STABILITY[gestureName];
            if (!stability) return currentValue;

            // Добавляем текущее значение в историю
            stability.history.push(currentValue);
            if (stability.history.length > GESTURE_HISTORY_SIZE) {
                stability.history.shift();
            }

            // Подсчитываем сколько раз жест был true в истории
            const trueCount = stability.history.filter(v => v).length;

            // Жест стабилен если выполнено минимальное требование
            return trueCount >= stability.required;
        }

        // Определение формы молекулы по комбинации пальцев в пинче
        function getShapeFromPinch(landmarks) {
            const thumbTip = landmarks[4];

            // Расстояния от большого пальца до каждого пальца
            const distances = {
                index: Math.sqrt((thumbTip.x - landmarks[8].x) ** 2 + (thumbTip.y - landmarks[8].y) ** 2),
                middle: Math.sqrt((thumbTip.x - landmarks[12].x) ** 2 + (thumbTip.y - landmarks[12].y) ** 2),
                ring: Math.sqrt((thumbTip.x - landmarks[16].x) ** 2 + (thumbTip.y - landmarks[16].y) ** 2),
                pinky: Math.sqrt((thumbTip.x - landmarks[20].x) ** 2 + (thumbTip.y - landmarks[20].y) ** 2)
            };

            // Порог касания - палец должен быть достаточно близко к большому пальцу
            const touchThreshold = 0.055; // СМЯГЧЕНО для стабильности (было 0.05)

            // Проверяем какой палец касается большого (приоритет у более дальних пальцев)
            // Проверяем в обратном порядке чтобы приоритет был у необычных жестов
            if (distances.pinky < touchThreshold) return 'star';        // Большой + мизинец = звезда
            if (distances.ring < touchThreshold) return 'heart';        // Большой + безымянный = сердце
            if (distances.middle < touchThreshold) return 'triangle';   // Большой + средний = треугольник
            if (distances.index < touchThreshold) return 'circle';      // Большой + указательный = круг

            // Если ни один палец не касается достаточно близко, используем ближайший
            const minDist = Math.min(distances.index, distances.middle, distances.ring, distances.pinky);
            if (minDist === distances.pinky) return 'star';
            if (minDist === distances.ring) return 'heart';
            if (minDist === distances.middle) return 'triangle';
            return 'circle'; // По умолчанию или если указательный ближе всех
        }

        // УЛУЧШЕНО: Определение основного жеста с приоритетом (для избежания конфликтов)
        function getPrimaryGesture(landmarks) {
            const pinchDist = getPinchDistance(landmarks);

            // Проверяем все жесты (raw detection)
            const rawGestures = {
                isPinching: isPinching(landmarks),  // УЛУЧШЕНО: используем новую функцию
                isPinky: isPinkyUp(landmarks),
                isCrossed: isFingersCrossed(landmarks),
                isFist: isHandFist(landmarks),
                isOpen: isHandOpen(landmarks)
            };

            // УЛУЧШЕНО: Применяем стабильность к каждому жесту индивидуально
            const stableGestures = {
                isPinching: isGestureStable('pinch', rawGestures.isPinching),
                isPinky: isGestureStable('pinky', rawGestures.isPinky),
                isCrossed: isGestureStable('crossed', rawGestures.isCrossed),
                isFist: isGestureStable('fist', rawGestures.isFist),
                isOpen: isGestureStable('open', rawGestures.isOpen)
            };

            // ПРИОРИТЕТ ЖЕСТОВ (от высокого к низкому):
            // 1. Мизинец - для разблокировки (очень специфичный жест)
            if (stableGestures.isPinky) {
                return {
                    isPinching: false,
                    isPinky: true,
                    isCrossed: false,
                    isFist: false,
                    isOpen: false,
                    primaryGesture: 'pinky'
                };
            }

            // 2. Скрещенные пальцы - для удаления (специфичный)
            if (stableGestures.isCrossed) {
                return {
                    isPinching: false,
                    isPinky: false,
                    isCrossed: true,
                    isFist: false,
                    isOpen: false,
                    primaryGesture: 'crossed'
                };
            }

            // 3. Все пальцы вместе - для фиксации (ПРИОРИТЕТ НАД PINCH!)
            // ВАЖНО: должен проверяться РАНЬШЕ чем обычный pinch
            if (stableGestures.isFist) {
                return {
                    isPinching: false,
                    isPinky: false,
                    isCrossed: false,
                    isFist: true,
                    isOpen: false,
                    primaryGesture: 'fist'
                };
            }

            // 4. Щипок - для создания молекул (после проверки "все пальцы вместе")
            if (stableGestures.isPinching) {
                return {
                    isPinching: true,
                    isPinky: false,
                    isCrossed: false,
                    isFist: false,
                    isOpen: false,
                    primaryGesture: 'pinch'
                };
            }

            // 5. Открытая ладонь - для перемещения (самый общий)
            if (stableGestures.isOpen) {
                return {
                    isPinching: false,
                    isPinky: false,
                    isCrossed: false,
                    isFist: false,
                    isOpen: true,
                    primaryGesture: 'open'
                };
            }

            // Нет распознанного жеста
            return {
                isPinching: false,
                isPinky: false,
                isCrossed: false,
                isFist: false,
                isOpen: false,
                primaryGesture: 'none'
            };
        }

        // Обработка результатов MediaPipe
        let frameCount = 0;
        function onResults(results) {
            const newHands = [];
            const currentFrame = [];

            // Логируем каждые 60 кадров
            frameCount++;
            if (frameCount === 1) {
                console.log('🎉 onResults вызван первый раз! MediaPipe работает!');
                console.log('✅ WASM успешно инициализирован');
                console.log('Загруженные файлы:', wasmFilesLoaded);
            }
            if (frameCount % 60 === 0) {
                console.log('MediaPipe Hands работает. Обнаружено рук:', results.multiHandLandmarks ? results.multiHandLandmarks.length : 0);
            }

            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, idx) => {
                    // УЛУЧШЕНО: Фильтрация по качеству ландмарков (если visibility доступен)
                    // Проверяем среднюю visibility всех ключевых ландмарков для надежности
                    const keyLandmarks = [0, 4, 8, 12, 16, 20]; // Запястье + кончики пальцев
                    let totalVisibility = 0;
                    let validCount = 0;

                    for (const idx of keyLandmarks) {
                        if (landmarks[idx] && landmarks[idx].visibility !== undefined) {
                            totalVisibility += landmarks[idx].visibility;
                            validCount++;
                        }
                    }

                    // ИСПРАВЛЕНО: Фильтруем только если visibility предоставляется И действительно низкий
                    // Если visibility не доступен (validCount === 0) - работаем как раньше, без фильтрации
                    if (validCount > 0) {
                        const avgVisibility = totalVisibility / validCount;

                        // Отбрасываем руку только если visibility очень низкий (< 0.3)
                        // Было 0.5, но это слишком строго - многие камеры дают visibility около 0.4-0.5
                        if (avgVisibility < 0.3) {
                            // Пропускаем эту руку - слишком низкая уверенность
                            return;
                        }
                    }
                    // Если visibility не доступен - пропускаем проверку, используем все детекции

                    const palm = landmarks[9];

                    // УЛУЧШЕНО: Расширенный маппинг координат для лучшего охвата краев экрана
                    // MediaPipe обычно дает координаты в диапазоне ~0.05-0.95 даже на краях видео
                    // Ремаппим этот диапазон на полный 0-1 чтобы можно было создавать молекулы на самом краю
                    const edgeMargin = 0.08; // Запас на краях (8%)
                    const remapX = Math.max(0, Math.min(1, (palm.x - edgeMargin) / (1 - 2 * edgeMargin)));
                    const remapY = Math.max(0, Math.min(1, (palm.y - edgeMargin) / (1 - 2 * edgeMargin)));

                    const handX = (1 - remapX) * width;  // Инвертируем X для зеркального отображения
                    const handY = remapY * height;

                    // УЛУЧШЕНО: Используем приоритетную систему жестов
                    const gestureResult = getPrimaryGesture(landmarks);
                    const pinchDist = getPinchDistance(landmarks);

                    const isPinching = gestureResult.isPinching;
                    const isOpen = gestureResult.isOpen;
                    const isFist = gestureResult.isFist;
                    const isCrossed = gestureResult.isCrossed;
                    const isPinky = gestureResult.isPinky;

                    // УЛУЧШЕНО: Используем точную детекцию загнутых пальцев
                    const fingersState = detectFoldedFingers(landmarks);

                    // Ширина раскрытия ладони (расстояние от большого пальца до мизинца)
                    const handWidth = Math.sqrt(
                        (landmarks[4].x - landmarks[20].x) ** 2 +
                        (landmarks[4].y - landmarks[20].y) ** 2
                    );

                    const handData = {
                        x: handX,
                        y: handY,
                        isPinching,
                        isOpen,
                        isFist,
                        isCrossed,
                        isPinky,
                        fingersState,
                        handWidth,
                        pinchDist // Сохраняем для изменения размера
                    };

                    newHands.push(handData);
                    currentFrame.push(handData);

                    // Создание молекулы при щипке с ЗАДЕРЖКОЙ 1 секунда
                    // УЛУЧШЕНО: добавлена проверка на скрещенные пальцы и мизинец
                    if (isPinching && !isFist && !isCrossed && !isPinky) {
                        // Сбрасываем время отпускания если pinch снова активен
                        pinchReleaseTime[idx] = null;

                        // Начинаем или продолжаем отсчет времени удержания pinch
                        if (pinchHoldStarts[idx] === null) {
                            pinchHoldStarts[idx] = Date.now();
                            // НЕ сбрасываем pinchCreatedFlags здесь - он сбросится только после полного отпускания
                        } else if (!pinchCreatedFlags[idx]) {
                            // Проверяем прошла ли 1 секунда
                            const holdTime = Date.now() - pinchHoldStarts[idx];
                            if (holdTime >= HOLD_DURATION) {
                                // Ограничение количества молекул для производительности
                                if (molecules.length < maxMolecules) {
                                    // Определяем форму по жесту (какой палец ближе к большому)
                                    const shapeFromGesture = getShapeFromPinch(landmarks);
                                    console.log('Создание молекулы через жест (удержание 1 сек), форма:', shapeFromGesture);
                                    const molecule = new Molecule(
                                        handX,
                                        handY,
                                        config.moleculeSize
                                    );
                                    // Устанавливаем форму напрямую из жеста
                                    molecule.shapes = [{type: shapeFromGesture, weight: 1}];
                                    molecules.push(molecule);
                                    saveState(); // Сохраняем состояние для отмены
                                    pinchCreatedFlags[idx] = true; // Помечаем что молекула создана
                                }
                            }
                        }
                    } else {
                        // Pinch отпущен
                        pinchHoldStarts[idx] = null;

                        // Если молекула была создана - запоминаем время отпускания для задержки сброса
                        if (pinchCreatedFlags[idx]) {
                            if (pinchReleaseTime[idx] === null) {
                                pinchReleaseTime[idx] = Date.now();
                            }

                            // Сбрасываем флаг только после 500 мс без pinch (чтобы избежать двойного создания)
                            const timeSinceRelease = Date.now() - pinchReleaseTime[idx];
                            if (timeSinceRelease >= 500) {
                                pinchCreatedFlags[idx] = false;
                                pinchReleaseTime[idx] = null;
                            }
                        } else {
                            // Если молекула не была создана - можно сбросить сразу
                            pinchCreatedFlags[idx] = false;
                            pinchReleaseTime[idx] = null;
                        }
                    }

                    previousPinchStates[idx] = isPinching;
                });
            }

            hands = newHands;

            // Добавляем текущий кадр в историю
            gestureHistory.push(currentFrame);
            if (gestureHistory.length > GESTURE_HISTORY_SIZE) {
                gestureHistory.shift(); // Удаляем старые кадры
            }
        }

        // Диагностика для отладки проблем с MediaPipe
        console.log('=== ДИАГНОСТИКА БРАУЗЕРА ===');
        console.log('Браузер:', navigator.userAgent);
        console.log('crossOriginIsolated:', window.crossOriginIsolated);
        console.log('SharedArrayBuffer:', typeof SharedArrayBuffer !== 'undefined');
        console.log('WebAssembly:', typeof WebAssembly !== 'undefined');

        // Отслеживание ошибок загрузки
        let wasmFilesLoaded = [];
        let wasmLoadErrors = [];

        window.addEventListener('error', (event) => {
            if (event.filename && event.filename.includes('mediapipe')) {
                console.error('❌ Ошибка загрузки MediaPipe:', event.filename, event.message);
                wasmLoadErrors.push(event.filename);
            }
        }, true);

        // Определяем окружение для правильных путей к MediaPipe
        const isLocalDevelopment = window.location.hostname === 'localhost' ||
                                    window.location.hostname === '127.0.0.1' ||
                                    window.location.hostname === '';

        // Теперь index.html в public/, поэтому пути одинаковые для обоих окружений
        const mediapipeBasePath = './mediapipe';
        console.log('Окружение:', isLocalDevelopment ? 'Live Server' : 'Production (Vercel)');
        console.log('MediaPipe базовый путь:', mediapipeBasePath);

        // Инициализация MediaPipe Hands
        console.log('=== ИНИЦИАЛИЗАЦИЯ MEDIAPIPE HANDS ===');
        const handsDetector = new Hands({
            locateFile: (file) => {
                console.log('📦 MediaPipe запрашивает:', file);
                wasmFilesLoaded.push(file);
                // Используем локальные файлы вместо CDN для быстрой загрузки
                const path = `${mediapipeBasePath}/hands/${file}`;
                console.log('  → Путь:', path);
                return path;
            }
        });

        handsDetector.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,  // Используем средний уровень сложности для баланса скорости/точности
            minDetectionConfidence: 0.8,  // УЛУЧШЕНО: было 0.7 - более строгая детекция на расстоянии
            minTrackingConfidence: 0.75   // УЛУЧШЕНО: было 0.7 - более надежное отслеживание
        });
        console.log('MediaPipe Hands настроен');

        handsDetector.onResults(onResults);
        console.log('Обработчик onResults подключен');

        // Инициализация MediaPipe FaceMesh для детекции открытого рта (отложенная, неблокирующая)
        let faceMesh = null;
        let faceMeshReady = false;

        // Инициализируем FaceMesh асинхронно, чтобы не блокировать Hands
        setTimeout(() => {
            console.log('=== ИНИЦИАЛИЗАЦИЯ MEDIAPIPE FACEMESH (асинхронно) ===');
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    console.log('📦 FaceMesh запрашивает:', file);
                    // Используем локальные файлы вместо CDN для быстрой загрузки
                    const path = `${mediapipeBasePath}/face_mesh/${file}`;
                    console.log('  → Путь:', path);
                    return path;
                }
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onFaceResults);
            faceMeshReady = true;
            console.log('✅ FaceMesh инициализирован');
        }, 1000); // Задержка 1 секунда, чтобы Hands загрузился первым

        // Обработка результатов FaceMesh
        function onFaceResults(results) {
            try {
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const landmarks = results.multiFaceLandmarks[0];

                    // FaceMesh использует индексы:
                    // 13 - верхняя внутренняя губа
                    // 14 - нижняя внутренняя губа
                    // Для более точного определения используем:
                    // 13 и 14 для внутренних точек губ
                    if (landmarks[13] && landmarks[14]) {
                        const upperLip = landmarks[13];
                        const lowerLip = landmarks[14];

                        // Расстояние между верхней и нижней губой
                        const mouthOpenDistance = Math.abs(lowerLip.y - upperLip.y);

                        // Если расстояние больше порога - рот открыт
                        // СТРОЖЕ: увеличен порог для предотвращения ложных срабатываний
                        const rawMouthOpen = mouthOpenDistance > 0.035; // Было 0.02, теперь строже

                        // СТАБИЛИЗАЦИЯ: рот должен быть открыт несколько кадров подряд
                        if (rawMouthOpen) {
                            mouthOpenFrames++;
                        } else {
                            mouthOpenFrames = 0;
                        }

                        // Рот считается открытым только если был открыт минимум 3 кадра подряд
                        isMouthOpen = mouthOpenFrames >= 3;

                        // TOGGLE режима редактирования при открытии рта
                        if (isMouthOpen && !wasMouthOpen) {
                            // Момент открытия рта - переключаем режим
                            if (editingMolecule) {
                                // Выключаем режим редактирования
                                editingMolecule.isEditing = false;
                                editingMolecule = null;
                            } else {
                                // Включаем режим для молекулы на которую наведена рука
                                // Приоритет: текущая hovered молекула > последняя hovered молекула
                                let moleculeToEdit = hoveredMolecule || lastHoveredMolecule;

                                if (moleculeToEdit && molecules.includes(moleculeToEdit)) {
                                    // Выключаем режим у всех молекул
                                    molecules.forEach(m => m.isEditing = false);
                                    // Включаем режим для выбранной
                                    moleculeToEdit.isEditing = true;
                                    editingMolecule = moleculeToEdit;
                                }
                            }
                        }

                        wasMouthOpen = isMouthOpen;
                    } else {
                        isMouthOpen = false;
                        wasMouthOpen = false;
                        mouthOpenFrames = 0;
                    }
                } else {
                    isMouthOpen = false;
                    wasMouthOpen = false;
                    mouthOpenFrames = 0;
                }
            } catch (error) {
                console.warn('Ошибка в onFaceResults:', error);
                isMouthOpen = false;
                wasMouthOpen = false;
                mouthOpenFrames = 0;
            }
        }

        // Инициализация камеры
        async function setupCamera() {
            console.log('Начинаем инициализацию камеры...');

            // Проверяем поддержку API
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('getUserMedia не поддерживается в этом браузере');
                status.textContent = 'Error: browser does not support camera access';
                return null;
            }

            try {
                console.log('Запрашиваем доступ к камере...');

                // Параметры видео для разных устройств
                const videoConstraints = isMobile ? {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'user' // Фронтальная камера для жестов
                } : {
                    width: 1280,
                    height: 720,
                    facingMode: 'user'
                };

                console.log('Параметры видео:', videoConstraints);

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: videoConstraints
                });

                console.log('Доступ к камере получен!', stream);
                video.srcObject = stream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        console.log('Метаданные видео загружены');
                        resolve(video);
                    };
                });
            } catch (error) {
                console.error('Ошибка доступа к камере:', error);
                console.error('Имя ошибки:', error.name);
                console.error('Сообщение:', error.message);

                status.textContent = `Camera error: ${error.name}`;

                // Пробуем с более простыми параметрами
                try {
                    console.log('Пробуем запросить камеру с базовыми параметрами...');
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: true
                    });
                    console.log('Доступ к камере получен (базовые параметры)!', stream);
                    video.srcObject = stream;
                    return new Promise((resolve) => {
                        video.onloadedmetadata = () => {
                            console.log('Метаданные видео загружены (базовые параметры)');
                            resolve(video);
                        };
                    });
                } catch (fallbackError) {
                    console.error('Не удалось получить доступ к камере:', fallbackError);
                    status.textContent = `Error: ${fallbackError.message}`;
                    return null;
                }
            }
        }

        // === ФУНКЦИИ ДЛЯ ОТМЕНЫ ДЕЙСТВИЙ (Ctrl+Z) ===

        // Сохранение текущего состояния в историю
        function saveState() {
            console.log(`💾 Сохраняем состояние: молекул = ${molecules.length}, штрихов = ${drawnStrokes.length}`);

            // Создаем глубокую копию текущего состояния
            const state = {
                molecules: molecules.map(mol => ({
                    x: mol.x,
                    y: mol.y,
                    baseSize: mol.baseSize,
                    size: mol.size,
                    stretchX: mol.stretchX,
                    stretchY: mol.stretchY,
                    deformAngle: mol.deformAngle,
                    shapes: mol.shapes ? mol.shapes.map(s => ({type: s.type, weight: s.weight})) : [{type: 'circle', weight: 1}], // ИСПРАВЛЕНО: сохраняем формы
                    fillColor: mol.fillColor,
                    edgeColor: mol.edgeColor,
                    emboss: mol.emboss,
                    microStripes: mol.microStripes,
                    stripeColor1: mol.stripeColor1,
                    stripeColor2: mol.stripeColor2,
                    stripeWidth: mol.stripeWidth,
                    stripeSpacing: mol.stripeSpacing
                })),
                drawnStrokes: drawnStrokes.map(stroke => ({
                    points: stroke.points.map(p => ({x: p.x, y: p.y, erased: p.erased})),
                    color: stroke.color,
                    width: stroke.width
                })),
                filledRegions: filledRegions.map(region => ({
                    imageData: new ImageData(
                        new Uint8ClampedArray(region.imageData.data),
                        region.imageData.width,
                        region.imageData.height
                    ),
                    x: region.x,
                    y: region.y,
                    width: region.width,
                    height: region.height
                })),
                backgroundFills: backgroundFills.map(region => ({
                    imageData: new ImageData(
                        new Uint8ClampedArray(region.imageData.data),
                        region.imageData.width,
                        region.imageData.height
                    ),
                    x: region.x,
                    y: region.y,
                    width: region.width,
                    height: region.height
                }))
            };

            history.push(state);

            // Ограничиваем размер истории
            if (history.length > MAX_HISTORY_SIZE) {
                history.shift(); // Удаляем самое старое состояние
            }

            console.log(`💾 Состояние сохранено | История: ${history.length}/${MAX_HISTORY_SIZE}`);
        }

        // Отмена последнего действия (Ctrl+Z)
        function undo() {
            console.log(`🔍 Отмена: история до = ${history.length}, молекул до = ${molecules.length}`);

            if (history.length === 0) {
                status.textContent = 'Nothing to undo';
                return;
            }

            // Удаляем текущее состояние (последнее в истории)
            history.pop();
            console.log(`🔍 Удалено последнее состояние, история после = ${history.length}`);

            // Если история пуста после удаления - восстанавливаем пустое состояние
            if (history.length === 0) {
                console.log(`🔍 История пуста, восстанавливаем пустое состояние`);
                molecules = [];
                drawnStrokes = [];
                filledRegions = [];
                backgroundFills = [];
                if (editorMode) {
                    frozenMolecules = [];
                }
                backgroundCacheValid = false; // Инвалидируем кеш фона
                status.textContent = `Undone all | Clear`;
                console.log(`↩️ Отменено всё`);
                return;
            }

            // Берем предыдущее состояние (теперь оно последнее)
            const state = history[history.length - 1];
            console.log(`🔍 Восстанавливаем состояние: молекул = ${state.molecules.length}, штрихов = ${state.drawnStrokes.length}`);

            // Восстанавливаем состояние
            molecules = state.molecules.map(mol => {
                // Создаем настоящий экземпляр Molecule
                const newMol = new Molecule(mol.x, mol.y, mol.size);

                // Восстанавливаем все свойства
                newMol.baseSize = mol.baseSize;
                newMol.stretchX = mol.stretchX;
                newMol.stretchY = mol.stretchY;
                newMol.deformAngle = mol.deformAngle;
                newMol.fillColor = mol.fillColor;
                newMol.edgeColor = mol.edgeColor;
                newMol.emboss = mol.emboss;
                newMol.microStripes = mol.microStripes;
                newMol.stripeColor1 = mol.stripeColor1;
                newMol.stripeColor2 = mol.stripeColor2;
                newMol.stripeWidth = mol.stripeWidth;
                newMol.stripeSpacing = mol.stripeSpacing;
                // Восстанавливаем формы
                if (mol.shapes && mol.shapes.length > 0) {
                    newMol.shapes = mol.shapes.map(s => ({type: s.type, weight: s.weight}));
                }

                return newMol;
            });

            drawnStrokes = state.drawnStrokes.map(stroke => ({
                points: stroke.points.map(p => ({x: p.x, y: p.y, erased: p.erased})),
                color: stroke.color,
                width: stroke.width
            }));

            filledRegions = state.filledRegions.map(region => ({
                imageData: new ImageData(
                    new Uint8ClampedArray(region.imageData.data),
                    region.imageData.width,
                    region.imageData.height
                ),
                x: region.x,
                y: region.y,
                width: region.width,
                height: region.height
            }));

            backgroundFills = state.backgroundFills.map(region => ({
                imageData: new ImageData(
                    new Uint8ClampedArray(region.imageData.data),
                    region.imageData.width,
                    region.imageData.height
                ),
                x: region.x,
                y: region.y,
                width: region.width,
                height: region.height
            }));

            // Обновляем frozenMolecules для режима редактора
            if (editorMode) {
                frozenMolecules = molecules.map(mol => ({
                    x: mol.x,
                    y: mol.y,
                    size: mol.size,
                    stretchX: mol.stretchX,
                    stretchY: mol.stretchY,
                    deformAngle: mol.deformAngle,
                    fillColor: mol.fillColor,
                    edgeColor: mol.edgeColor,
                    emboss: mol.emboss,
                    microStripes: mol.microStripes
                }));
            }

            // Инвалидируем кеш фона, так как состояние изменилось
            backgroundCacheValid = false;

            status.textContent = `Undone | Remaining: ${history.length}`;
            console.log(`↩️ Отменено действие | История: ${history.length}/${MAX_HISTORY_SIZE} | Молекул после: ${molecules.length}`);
        }

        // Инициализация размеров
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            backgroundCacheValid = false; // Инвалидируем кеш фона при изменении размера

            // Адаптивный размер молекул в зависимости от ширины экрана
            // Базовый размер 150px для экрана 1920px
            // Для маленьких экранов (смартфоны ~400px) размер будет ~60px
            const screenScale = Math.max(0.3, Math.min(1, width / 1500));
            config.moleculeSize = Math.round(150 * screenScale);

            // Адаптируем минимальный и максимальный размеры молекул
            minMoleculeSize = Math.round(30 * screenScale);   // 30px -> ~12px на смартфоне
            maxMoleculeSize = Math.round(300 * screenScale);  // 300px -> ~120px на смартфоне
        }

        // Основной цикл анимации
        function animate() {
            // Полная очистка canvas в начале каждого кадра
            // Это предотвращает следы от движущихся объектов
            ctx.clearRect(0, 0, width, height);

            // Если включено "показать видео" - рисуем видео с камеры как фон
            if (config.showVideo && video.videoWidth > 0) {
                ctx.save();
                // Отзеркаливаем видео
                ctx.scale(-1, 1);
                ctx.drawImage(video, -width, 0, width, height);
                ctx.restore();
            }

            // Анализируем звук (только в режиме жестов)
            if (config.audioEnabled && !editorMode) {
                analyzeAudio();
            }

            // Фиксация с таймером
            const fists = hands.filter(h => h.isFist);
            const twoFistsStable = checkStableTwoHands('isFist');

            // ФИКСАЦИЯ ВСЕХ МОЛЕКУЛ - жест "пальцы вместе" двумя руками удерживать 2 секунды
            if (fists.length === 2 && twoFistsStable) {
                if (twoFistsHoldStart === null) {
                    twoFistsHoldStart = Date.now();
                } else {
                    const holdDuration = Date.now() - twoFistsHoldStart;
                    if (holdDuration >= HOLD_DURATION) {
                        // Фиксируем ВСЕ молекулы
                        molecules.forEach(mol => {
                            if (!mol.isLocked) {
                                mol.isLocked = true;
                                mol.isShapeLocked = true;
                                mol.isGrabbed = false;
                                // НЕ сбрасываем isEditing автоматически
                            }
                        });
                    }
                }
            } else {
                twoFistsHoldStart = null;
            }

            // ФИКСАЦИЯ ОДНОЙ МОЛЕКУЛЫ - жест "пальцы вместе" над молекулой удерживать 2 секунды
            if (fists.length === 1 && hands.length === 1) {
                const fist = fists[0];
                let closestMol = null;
                let closestDist = Infinity;

                // Находим ближайшую незаблокированную молекулу
                molecules.forEach(mol => {
                    if (!mol.isLocked) {
                        const dist = Math.sqrt((mol.x - fist.x) ** 2 + (mol.y - fist.y) ** 2);
                        if (dist < 150 && dist < closestDist) {
                            closestDist = dist;
                            closestMol = mol;
                        }
                    }
                });

                if (closestMol) {
                    if (fistHoldMolecule === closestMol) {
                        // Продолжаем удерживать над той же молекулой
                        const holdDuration = Date.now() - fistHoldStart;
                        if (holdDuration >= HOLD_DURATION) {
                            // Фиксируем эту молекулу
                            closestMol.isLocked = true;
                            closestMol.isShapeLocked = true;
                            closestMol.isGrabbed = false;
                            // НЕ СБРАСЫВАЕМ isEditing - можно продолжать редактировать другие
                            fistHoldStart = null;
                            fistHoldMolecule = null;
                        }
                    } else {
                        // Начинаем отсчет с новой молекулой
                        fistHoldStart = Date.now();
                        fistHoldMolecule = closestMol;
                    }
                } else {
                    fistHoldStart = null;
                    fistHoldMolecule = null;
                }
            } else {
                fistHoldStart = null;
                fistHoldMolecule = null;
            }

            // РАЗБЛОКИРОВКА МИЗИНЦЕМ - показать мизинец на заблокированной молекуле
            const pinkyHands = hands.filter(h => h.isPinky);
            if (pinkyHands.length === 1) {
                const pinky = pinkyHands[0];
                molecules.forEach(mol => {
                    if (mol.isLocked) {
                        const dist = Math.sqrt((mol.x - pinky.x) ** 2 + (mol.y - pinky.y) ** 2);
                        if (dist < 150) {
                            mol.isLocked = false;
                            mol.isShapeLocked = false;
                        }
                    }
                });
            }

            // Обновление молекул (только в режиме жестов)
            if (!editorMode) {
                molecules.forEach(mol => mol.update());

                // ПРОВЕРКА И СЛИЯНИЕ МОЛЕКУЛ
                checkAndMergeMolecules();
            }

            // ОТСЛЕЖИВАНИЕ МОЛЕКУЛЫ ПОД ЛАДОНЬЮ (для выбора при редактировании)
            hoveredMolecule = null;
            const openHands = hands.filter(h => h.isOpen && !h.isPinching && !h.isFist && !h.isCrossed && !h.isPinky);
            if (openHands.length > 0) {
                // Ищем ближайшую молекулу под любой открытой ладонью
                let closestMol = null;
                let closestDist = Infinity;

                openHands.forEach(hand => {
                    molecules.forEach(mol => {
                        const dist = Math.sqrt((mol.x - hand.x) ** 2 + (mol.y - hand.y) ** 2);
                        if (dist < 150 && dist < closestDist) {
                            closestDist = dist;
                            closestMol = mol;
                        }
                    });
                });

                if (closestMol) {
                    hoveredMolecule = closestMol;
                    lastHoveredMolecule = closestMol;
                }
            }

            // УДАЛЕНИЕ МОЛЕКУЛЫ - скрещенные пальцы удерживать 2 секунды
            const crossedHands = hands.filter(h => h.isCrossed);
            if (crossedHands.length === 1) {
                const crossed = crossedHands[0];
                let closestMol = null;
                let closestDist = Infinity;

                // Находим ближайшую молекулу
                molecules.forEach(mol => {
                    const dist = Math.sqrt((mol.x - crossed.x) ** 2 + (mol.y - crossed.y) ** 2);
                    if (dist < 120 && dist < closestDist) {
                        closestDist = dist;
                        closestMol = mol;
                    }
                });

                if (closestMol) {
                    // УЛУЧШЕНО: Жест обнаружен - сбрасываем счётчик потери
                    crossedHoldLostTime = null;

                    if (crossedHoldMolecule === closestMol) {
                        // Продолжаем удерживать над той же молекулой
                        const holdDuration = Date.now() - crossedHoldStart;
                        if (holdDuration >= HOLD_DURATION) {
                            // Удаляем молекулу после 2 секунд
                            // Сбрасываем режим редактирования если удаляемая молекула в этом режиме
                            if (editingMolecule === closestMol) {
                                editingMolecule = null;
                            }
                            // Сбрасываем lastHoveredMolecule если это она
                            if (lastHoveredMolecule === closestMol) {
                                lastHoveredMolecule = null;
                            }
                            molecules = molecules.filter(m => m !== closestMol);
                            crossedHoldStart = null;
                            crossedHoldMolecule = null;
                            crossedHoldLostTime = null;
                        }
                    } else {
                        // Начинаем отсчет с новой молекулой
                        crossedHoldStart = Date.now();
                        crossedHoldMolecule = closestMol;
                        crossedHoldLostTime = null;
                    }
                } else {
                    // УЛУЧШЕНО: Нет молекулы рядом - используем толерантность
                    if (crossedHoldStart && !crossedHoldLostTime) {
                        crossedHoldLostTime = Date.now();
                    } else if (crossedHoldLostTime && (Date.now() - crossedHoldLostTime > RESET_TOLERANCE)) {
                        crossedHoldStart = null;
                        crossedHoldMolecule = null;
                        crossedHoldLostTime = null;
                    }
                }
            } else {
                // УЛУЧШЕНО: Жест потерян - используем толерантность перед сбросом
                if (crossedHoldStart && !crossedHoldLostTime) {
                    crossedHoldLostTime = Date.now();
                } else if (crossedHoldLostTime && (Date.now() - crossedHoldLostTime > RESET_TOLERANCE)) {
                    crossedHoldStart = null;
                    crossedHoldMolecule = null;
                    crossedHoldLostTime = null;
                }
            }

            // Рисование метаболлов с мониторингом производительности
            const renderStartTime = performance.now();

            drawMetaballs();

            // Измеряем время рендеринга и адаптируем качество
            const renderTime = performance.now() - renderStartTime;
            adaptRenderingQuality(renderTime);

            // Визуализация прогресса таймеров

            // Прогресс фиксации одной молекулы
            if (fistHoldMolecule && fistHoldStart) {
                const progress = (Date.now() - fistHoldStart) / HOLD_DURATION;
                const angle = Math.PI * 2 * progress;

                ctx.strokeStyle = 'rgba(255, 200, 0, 0.9)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(fistHoldMolecule.x, fistHoldMolecule.y, 35, -Math.PI / 2, -Math.PI / 2 + angle);
                ctx.stroke();

                // Текст прогресса
                ctx.fillStyle = 'rgba(255, 200, 0, 0.9)';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('LOCK', fistHoldMolecule.x, fistHoldMolecule.y);
            }

            // Прогресс удаления молекулы
            if (crossedHoldMolecule && crossedHoldStart) {
                const progress = (Date.now() - crossedHoldStart) / HOLD_DURATION;
                const angle = Math.PI * 2 * progress;

                ctx.strokeStyle = 'rgba(255, 50, 50, 0.9)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(crossedHoldMolecule.x, crossedHoldMolecule.y, 35, -Math.PI / 2, -Math.PI / 2 + angle);
                ctx.stroke();

                // Текст прогресса
                ctx.fillStyle = 'rgba(255, 50, 50, 0.9)';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('DEL', crossedHoldMolecule.x, crossedHoldMolecule.y);
            }

            // Визуализация захваченных/заблокированных молекул
            molecules.forEach(mol => {
                if (mol.isLocked) {
                    if (mol.isShapeLocked) {
                        // Двойной крестик для зафиксированной формы
                        ctx.strokeStyle = 'rgba(255, 100, 0, 0.8)';
                        ctx.lineWidth = 3;
                        const size = 15;

                        // Внешний крестик
                        ctx.beginPath();
                        ctx.moveTo(mol.x - size, mol.y - size);
                        ctx.lineTo(mol.x + size, mol.y + size);
                        ctx.moveTo(mol.x + size, mol.y - size);
                        ctx.lineTo(mol.x - size, mol.y + size);
                        ctx.stroke();

                        // Внутренний крестик
                        ctx.strokeStyle = 'rgba(255, 150, 50, 0.6)';
                        ctx.lineWidth = 2;
                        const smallSize = 8;
                        ctx.beginPath();
                        ctx.moveTo(mol.x - smallSize, mol.y - smallSize);
                        ctx.lineTo(mol.x + smallSize, mol.y + smallSize);
                        ctx.moveTo(mol.x + smallSize, mol.y - smallSize);
                        ctx.lineTo(mol.x - smallSize, mol.y + smallSize);
                        ctx.stroke();
                    } else {
                        // Красный крестик для заблокированной позиции
                        ctx.strokeStyle = 'rgba(255, 50, 50, 0.7)';
                        ctx.lineWidth = 3;
                        const size = 15;
                        ctx.beginPath();
                        ctx.moveTo(mol.x - size, mol.y - size);
                        ctx.lineTo(mol.x + size, mol.y + size);
                        ctx.moveTo(mol.x + size, mol.y - size);
                        ctx.lineTo(mol.x - size, mol.y + size);
                        ctx.stroke();
                    }
                } else if (mol.isEditing) {
                    // ВИЗУАЛЬНЫЙ ПРЕВЬЮ ДЕФОРМАЦИИ

                    // 1. Яркий пульсирующий круг для режима редактирования
                    const pulse = 0.5 + Math.sin(Date.now() / 300) * 0.2;
                    ctx.strokeStyle = `rgba(50, 150, 255, ${pulse})`;
                    ctx.lineWidth = 5;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.arc(mol.x, mol.y, 35 + Math.sin(Date.now() / 400) * 3, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // 2. НОВОЕ: Визуализация рук и оси деформации
                    if (mol.editingHands) {
                        const h1 = mol.editingHands.hand1;
                        const h2 = mol.editingHands.hand2;

                        // Линия между руками (зелёная) - ось растяжения
                        ctx.strokeStyle = 'rgba(50, 255, 100, 0.8)';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([10, 5]);
                        ctx.beginPath();
                        ctx.moveTo(h1.x, h1.y);
                        ctx.lineTo(h2.x, h2.y);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Точки рук
                        ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                        ctx.beginPath();
                        ctx.arc(h1.x, h1.y, 10, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.fillStyle = 'rgba(255, 150, 50, 0.9)';
                        ctx.beginPath();
                        ctx.arc(h2.x, h2.y, 10, 0, Math.PI * 2);
                        ctx.fill();

                        // Ось деформации через молекулу
                        const axisLength = mol.size * mol.stretchX * 0.8;
                        const axisX1 = mol.x + Math.cos(mol.deformAngle) * axisLength;
                        const axisY1 = mol.y + Math.sin(mol.deformAngle) * axisLength;
                        const axisX2 = mol.x - Math.cos(mol.deformAngle) * axisLength;
                        const axisY2 = mol.y - Math.sin(mol.deformAngle) * axisLength;

                        ctx.strokeStyle = 'rgba(255, 100, 255, 0.7)';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([8, 4]);
                        ctx.beginPath();
                        ctx.moveTo(axisX1, axisY1);
                        ctx.lineTo(axisX2, axisY2);
                        ctx.stroke();

                        // Перпендикулярная ось (сжатие)
                        const perpAngle = mol.deformAngle + Math.PI / 2;
                        const perpLength = mol.size * mol.stretchY * 0.8;
                        const perpX1 = mol.x + Math.cos(perpAngle) * perpLength;
                        const perpY1 = mol.y + Math.sin(perpAngle) * perpLength;
                        const perpX2 = mol.x - Math.cos(perpAngle) * perpLength;
                        const perpY2 = mol.y - Math.sin(perpAngle) * perpLength;

                        ctx.strokeStyle = 'rgba(100, 255, 255, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([4, 4]);
                        ctx.beginPath();
                        ctx.moveTo(perpX1, perpY1);
                        ctx.lineTo(perpX2, perpY2);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Индикаторы степени растяжения
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';

                        // Растяжение вдоль (X)
                        ctx.fillStyle = 'rgba(255, 100, 255, 0.9)';
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.lineWidth = 3;
                        ctx.strokeText(`${mol.stretchX.toFixed(1)}x`, axisX1 + Math.cos(mol.deformAngle) * 20, axisY1 + Math.sin(mol.deformAngle) * 20);
                        ctx.fillText(`${mol.stretchX.toFixed(1)}x`, axisX1 + Math.cos(mol.deformAngle) * 20, axisY1 + Math.sin(mol.deformAngle) * 20);

                        // Сжатие поперёк (Y)
                        ctx.fillStyle = 'rgba(100, 255, 255, 0.9)';
                        ctx.strokeText(`${mol.stretchY.toFixed(1)}x`, perpX1 + Math.cos(perpAngle) * 20, perpY1 + Math.sin(perpAngle) * 20);
                        ctx.fillText(`${mol.stretchY.toFixed(1)}x`, perpX1 + Math.cos(perpAngle) * 20, perpY1 + Math.sin(perpAngle) * 20);
                    }

                    // 3. Иконка редактирования
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = 'rgba(50, 150, 255, 0.9)';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.strokeText('✎', mol.x, mol.y - 50);
                    ctx.fillText('✎', mol.x, mol.y - 50);

                    // 4. Подсказка о режиме
                    ctx.font = '13px Arial';
                    ctx.fillStyle = 'rgba(50, 150, 255, 0.8)';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.lineWidth = 2;
                    const hint = 'Edit mode (open mouth to exit)';
                    ctx.strokeText(hint, mol.x, mol.y + 55);
                    ctx.fillText(hint, mol.x, mol.y + 55);
                } else if (mol.isGrabbed) {
                    // Зелёный круг для захваченных
                    ctx.strokeStyle = 'rgba(50, 255, 50, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(mol.x, mol.y, 25, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // НОВОЕ: Подсветка молекулы под ладонью (готова к выбору для редактирования)
                if (mol === hoveredMolecule && !mol.isEditing && !mol.isLocked) {
                    // Жёлтый круг с пунктиром - показывает что эта молекула будет выбрана
                    ctx.strokeStyle = 'rgba(255, 200, 50, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([6, 3]);
                    ctx.beginPath();
                    ctx.arc(mol.x, mol.y, 28, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Подсказка
                    ctx.font = '11px Arial';
                    ctx.fillStyle = 'rgba(255, 200, 50, 0.9)';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    const hintText = 'Open mouth to edit';
                    ctx.strokeText(hintText, mol.x, mol.y + 35);
                    ctx.fillText(hintText, mol.x, mol.y + 35);
                }

                // PAINT РЕДАКТОР: Подсветка выбранной молекулы
                if (editorMode && mol === selectedMolecule) {
                    // Пульсирующий контур с difference режимом (инвертированный цвет)
                    ctx.save();
                    ctx.globalCompositeOperation = 'difference';

                    const pulse = 0.6 + Math.sin(Date.now() / 200) * 0.3;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                    ctx.lineWidth = 4;
                    ctx.setLineDash([8, 4]);
                    ctx.beginPath();
                    ctx.arc(mol.x, mol.y, mol.size * 1.1, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.restore();
                }

                // UI ИНСТРУМЕНТЫ: Подсветка молекулы выбранной через панель инструментов
                if (!editorMode && mol === selectedMoleculeUI) {
                    // Пульсирующий контур с difference режимом (инвертированный цвет)
                    ctx.save();
                    ctx.globalCompositeOperation = 'difference';

                    const pulse = 0.7 + Math.sin(Date.now() / 250) * 0.3;

                    // Внешний круг
                    ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
                    ctx.lineWidth = 5;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.arc(mol.x, mol.y, mol.size * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Дополнительный внутренний круг
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 + pulse * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(mol.x, mol.y, mol.size * 0.9, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.restore();
                }
            });

            // Визуализация рук
            hands.forEach(hand => {
                let color, iconKey;
                // УЛУЧШЕНО: Приоритетный порядок отображения жестов
                if (hand.isPinching) {
                    color = 'rgba(255, 100, 100, 0.6)';
                    iconKey = null; // No icon for pinch yet
                } else if (hand.isPinky) {
                    color = 'rgba(255, 200, 0, 0.7)';
                    iconKey = 'unlock';
                } else if (hand.isCrossed) {
                    color = 'rgba(255, 50, 150, 0.7)';
                    iconKey = 'delete';
                } else if (hand.isFist) {
                    color = 'rgba(255, 150, 50, 0.6)';
                    iconKey = 'lock';
                } else if (hand.isOpen) {
                    color = 'rgba(100, 255, 100, 0.6)';
                    iconKey = 'open';
                } else {
                    color = 'rgba(150, 150, 150, 0.5)';
                    iconKey = null;
                }

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(hand.x, hand.y, 15, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Icon для жеста
                if (iconKey && gestureIconsLoaded && gestureIcons[iconKey]) {
                    const iconSize = 24;
                    ctx.drawImage(
                        gestureIcons[iconKey],
                        hand.x - iconSize / 2,
                        hand.y - 50,
                        iconSize,
                        iconSize
                    );
                }

                // Индикатор прогресса удержания pinch для создания молекулы
                if (hand.isPinching && !hand.isFist && !hand.isCrossed && !hand.isPinky) {
                    const idx = hands.indexOf(hand);
                    if (pinchHoldStarts[idx] !== null && !pinchCreatedFlags[idx]) {
                        const holdTime = Date.now() - pinchHoldStarts[idx];
                        const progress = Math.min(holdTime / HOLD_DURATION, 1);

                        // Рисуем круговой индикатор прогресса
                        ctx.strokeStyle = 'rgba(50, 200, 50, 0.8)';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(hand.x, hand.y, 25, -Math.PI / 2, -Math.PI / 2 + progress * Math.PI * 2);
                        ctx.stroke();

                        // Текст с процентами
                        ctx.fillStyle = 'rgba(50, 200, 50, 0.9)';
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(`${Math.round(progress * 100)}%`, hand.x, hand.y + 45);
                    }
                }
            });

            // Линия между двумя руками
            const openHandsForLine = hands.filter(h => h.isOpen);
            if (openHandsForLine.length === 2) {
                // Если молекула в режиме редактирования - показываем специальную линию
                const inEditMode = editingMolecule && editingMolecule.isEditing;

                if (inEditMode) {
                    // Яркая анимированная линия для режима редактирования
                    const gradient = ctx.createLinearGradient(
                        openHandsForLine[0].x, openHandsForLine[0].y,
                        openHandsForLine[1].x, openHandsForLine[1].y
                    );
                    gradient.addColorStop(0, 'rgba(50, 150, 255, 0.7)');
                    gradient.addColorStop(0.5, 'rgba(100, 200, 255, 0.9)');
                    gradient.addColorStop(1, 'rgba(50, 150, 255, 0.7)');

                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 4;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.moveTo(openHandsForLine[0].x, openHandsForLine[0].y);
                    ctx.lineTo(openHandsForLine[1].x, openHandsForLine[1].y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Показываем расстояние
                    const distX = Math.abs(openHandsForLine[1].x - openHandsForLine[0].x);
                    const distY = Math.abs(openHandsForLine[1].y - openHandsForLine[0].y);
                    const midX = (openHandsForLine[0].x + openHandsForLine[1].x) / 2;
                    const midY = (openHandsForLine[0].y + openHandsForLine[1].y) / 2;

                    ctx.font = '12px Arial';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Вычисляем расстояние и угол
                    const totalDist = Math.round(Math.sqrt(distX * distX + distY * distY));
                    const angle = Math.round(editingMolecule.targetDeformAngle * 180 / Math.PI);

                    // Показываем информацию о деформации
                    const text = `Расстояние: ${totalDist}px | Угол: ${angle}°`;
                    ctx.strokeText(text, midX, midY - 10);
                    ctx.fillText(text, midX, midY - 10);

                    // Дополнительная информация
                    const stretchInfo = `Растяжение: ${editingMolecule.stretchX.toFixed(2)} × ${editingMolecule.stretchY.toFixed(2)}`;
                    ctx.font = '10px Arial';
                    ctx.strokeText(stretchInfo, midX, midY + 10);
                    ctx.fillText(stretchInfo, midX, midY + 10);
                } else {
                    // Обычная линия
                    ctx.strokeStyle = 'rgba(100, 255, 100, 0.4)';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(openHandsForLine[0].x, openHandsForLine[0].y);
                    ctx.lineTo(openHandsForLine[1].x, openHandsForLine[1].y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Индикатор режима производительности (только в режиме низкой производительности)
            let currentYOffset = 10;
            if (isLowPerformanceMode && frameTimeHistory.length > 0) {
                const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;
                const fps = Math.round(1000 / avgFrameTime);

                ctx.save();
                ctx.fillStyle = 'rgba(255, 150, 0, 0.8)';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';

                const text = `⚡ Режим оптимизации | ${fps} FPS | Качество: низкое`;
                const padding = 10;
                const textMetrics = ctx.measureText(text);
                const boxWidth = textMetrics.width + padding * 2;
                const boxHeight = 30;

                // Фон
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, currentYOffset, boxWidth, boxHeight);

                // Текст
                ctx.fillStyle = 'rgba(255, 200, 100, 1)';
                ctx.fillText(text, 10 + padding, currentYOffset + padding);
                ctx.restore();

                currentYOffset += boxHeight + 10; // Смещение для следующего индикатора
            }

            requestAnimationFrame(animate);
        }

        // Обработка видео для MediaPipe
        let detectHandsStarted = false;
        let sendCount = 0;
        async function detectHands() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                if (!detectHandsStarted) {
                    console.log('✅ Видео готово, начинаем детекцию рук');
                    detectHandsStarted = true;
                }
                try {
                    sendCount++;
                    if (sendCount === 1) {
                        console.log('Отправляем первый кадр в MediaPipe...');
                    }
                    if (sendCount === 30 && frameCount === 0) {
                        console.warn('⚠️ Отправлено 30 кадров, но onResults ни разу не вызван!');
                        console.warn('MediaPipe WASM не инициализировался.');
                        console.warn('Загружено файлов:', wasmFilesLoaded);
                        console.warn('Ошибки загрузки:', wasmLoadErrors.length > 0 ? wasmLoadErrors : 'нет');
                        console.warn('crossOriginIsolated:', window.crossOriginIsolated);
                    }
                    if (sendCount === 100 && frameCount === 0) {
                        console.error('❌ КРИТИЧЕСКАЯ ОШИБКА: MediaPipe не работает после 100 кадров!');
                        console.error('Это может быть проблема с CORS или COEP политикой.');
                        console.error('Проверьте Network вкладку в DevTools для деталей.');
                    }

                    await handsDetector.send({ image: video });
                    // FaceMesh опционально - не блокирует работу рук
                    if (faceMeshReady && faceMesh) {
                        try {
                            await faceMesh.send({ image: video });
                        } catch (faceError) {
                            // Игнорируем ошибки FaceMesh
                        }
                    }
                } catch (error) {
                    console.error('❌ Ошибка детекции рук:', error);
                }
            }
            requestAnimationFrame(detectHands);
        }

        // UI контролы
        document.getElementById('molSizeSlider').addEventListener('input', (e) => {
            config.moleculeSize = parseInt(e.target.value);
            document.getElementById('molSize').textContent = config.moleculeSize;
        });

        document.getElementById('shapeSelector').addEventListener('change', (e) => {
            selectedShape = e.target.value;

            // Если есть выбранная молекула через UI инструменты - меняем её форму
            if (selectedMoleculeUI && moleculeTool === 'select') {
                selectedMoleculeUI.shapes = [{type: selectedShape, weight: 1}];
                saveState();
                status.textContent = `Molecule shape changed to: ${selectedShape}`;
            }
        });

        // Custom select initialization
        const customSelect = document.querySelector('.custom-select');
        const customSelectTrigger = document.querySelector('.custom-select-trigger');
        const customOptions = document.querySelectorAll('.custom-option');
        const realSelect = document.getElementById('shapeSelector');

        customSelectTrigger.addEventListener('click', function() {
            customSelect.classList.toggle('open');
        });

        customOptions.forEach(option => {
            option.addEventListener('click', function() {
                const value = this.getAttribute('data-value');
                const text = this.textContent;

                // Update trigger text
                customSelectTrigger.textContent = text;

                // Update real select
                realSelect.value = value;
                realSelect.dispatchEvent(new Event('change'));

                // Remove selected class from all options
                customOptions.forEach(opt => opt.classList.remove('selected'));

                // Add selected class to clicked option
                this.classList.add('selected');

                // Close dropdown
                customSelect.classList.remove('open');
            });
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!customSelect.contains(e.target)) {
                customSelect.classList.remove('open');
            }
        });

        document.getElementById('mergeSlider').addEventListener('input', (e) => {
            config.mergeStrength = parseFloat(e.target.value);
            document.getElementById('mergeStrength').textContent = config.mergeStrength.toFixed(1);
        });

        document.getElementById('audioSensSlider').addEventListener('input', (e) => {
            config.audioSensitivity = parseInt(e.target.value);
            document.getElementById('audioSens').textContent = config.audioSensitivity;
        });

        document.getElementById('audioEnabled').addEventListener('change', (e) => {
            config.audioEnabled = e.target.checked;
        });

        document.getElementById('showVideo').addEventListener('change', (e) => {
            config.showVideo = e.target.checked;
            video.style.opacity = config.showVideo ? '0.3' : '0';
        });

        document.getElementById('lockBtn').addEventListener('click', () => {
            molecules.forEach(mol => mol.lock());
        });

        document.getElementById('unlockBtn').addEventListener('click', () => {
            molecules.forEach(mol => mol.unlock());
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            molecules = [];
        });

        // ЭКСПОРТ: PNG (с фоном или без в зависимости от галочки)
        document.getElementById('exportPngBtn').addEventListener('click', () => {
            const withBackground = document.getElementById('exportWithBackground').checked;

            if (withBackground) {
                // Экспорт с фоном - просто сохраняем текущий canvas
                const link = document.createElement('a');
                link.download = `molecules_${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                status.textContent = 'PNG exported (with background)';
            } else {
                // Экспорт без фона - временно отключаем фон
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;

                // Сохраняем настройки
                const originalBgType = backgroundType;
                const originalBgImage = backgroundImage;
                const originalBgColor = backgroundColor;
                const originalShowVideo = config.showVideo;

                // Временно отключаем фон
                backgroundType = 'transparent';
                backgroundImage = null;
                config.showVideo = false;

                // Рисуем один кадр без фона на основном canvas
                drawMetaballs();

                // Копируем результат на временный canvas
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(canvas, 0, 0);

                // Восстанавливаем настройки
                backgroundType = originalBgType;
                backgroundImage = originalBgImage;
                backgroundColor = originalBgColor;
                config.showVideo = originalShowVideo;

                // Перерисовываем с фоном (чтобы вернуть на экран)
                drawMetaballs();

                // Экспортируем
                const link = document.createElement('a');
                link.download = `molecules_transparent_${Date.now()}.png`;
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
                status.textContent = 'PNG exported (no background)';
            }
        });

        // ЭКСПОРТ: Запись видео
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = null;
        let savedBackgroundSettings = null;

        document.getElementById('recordVideoBtn').addEventListener('click', async () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                // Остановка записи
                mediaRecorder.stop();

                // Восстанавливаем фон, если он был отключен
                if (savedBackgroundSettings) {
                    backgroundType = savedBackgroundSettings.bgType;
                    backgroundImage = savedBackgroundSettings.bgImage;
                    backgroundColor = savedBackgroundSettings.bgColor;
                    config.showVideo = savedBackgroundSettings.showVideo;
                    savedBackgroundSettings = null;
                    drawMetaballs();
                }
                return;
            }

            try {
                const withBackground = document.getElementById('exportWithBackground').checked;

                // Если запись без фона - сохраняем и отключаем фон
                if (!withBackground) {
                    savedBackgroundSettings = {
                        bgType: backgroundType,
                        bgImage: backgroundImage,
                        bgColor: backgroundColor,
                        showVideo: config.showVideo
                    };

                    backgroundType = 'transparent';
                    backgroundImage = null;
                    config.showVideo = false;
                    drawMetaballs();
                }

                // Начинаем запись
                const stream = canvas.captureStream(60); // 60 FPS
                const options = { mimeType: 'video/webm;codecs=vp9' };

                // Проверяем поддержку формата
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm'; // fallback
                }

                mediaRecorder = new MediaRecorder(stream, options);
                recordedChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        recordedChunks.push(e.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `molecules_animation_${Date.now()}.webm`;
                    link.click();
                    URL.revokeObjectURL(url);

                    // Восстанавливаем фон, если он был отключен
                    if (savedBackgroundSettings) {
                        backgroundType = savedBackgroundSettings.bgType;
                        backgroundImage = savedBackgroundSettings.bgImage;
                        backgroundColor = savedBackgroundSettings.bgColor;
                        config.showVideo = savedBackgroundSettings.showVideo;
                        savedBackgroundSettings = null;
                        drawMetaballs();
                    }

                    document.getElementById('recordBtnText').textContent = 'Record video (30 sec)';
                    status.textContent = 'Video saved';
                };

                mediaRecorder.start();
                recordingStartTime = Date.now();
                document.getElementById('recordBtnText').textContent = 'Stop recording';
                status.textContent = withBackground ? 'Recording video with background... (30 sec)' : 'Recording video without background... (30 sec)';

                // Автоматическая остановка через 30 секунд
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                }, 30000);

            } catch (err) {
                console.error('Ошибка записи видео:', err);
                status.textContent = 'Video recording error';

                // Восстанавливаем фон в случае ошибки
                if (savedBackgroundSettings) {
                    backgroundType = savedBackgroundSettings.bgType;
                    backgroundImage = savedBackgroundSettings.bgImage;
                    backgroundColor = savedBackgroundSettings.bgColor;
                    config.showVideo = savedBackgroundSettings.showVideo;
                    savedBackgroundSettings = null;
                    drawMetaballs();
                }
            }
        });

        // UI сворачивание/разворачивание панелей
        const controlsPanel = document.getElementById('controls');
        const toggleHintsBtn = document.getElementById('toggleHints');
        const toggleControlsBtn = document.getElementById('toggleControls');
        const closeControlsBtn = document.getElementById('closeControls');

        // Открыть книгу с мануалом
        toggleHintsBtn.addEventListener('click', () => {
            window.open('manual.html', '_blank');
        });

        // Скрыть панель управления
        closeControlsBtn.addEventListener('click', () => {
            controlsPanel.classList.add('minimized');
            toggleControlsBtn.classList.add('visible');
        });

        // Показать панель управления
        toggleControlsBtn.addEventListener('click', () => {
            controlsPanel.classList.remove('minimized');
            toggleControlsBtn.classList.remove('visible');
        });

        // === ПАНЕЛЬ ИНСТРУМЕНТОВ ===
        const toolbox = document.getElementById('toolbox');
        const toggleToolboxBtn = document.getElementById('toggleToolbox');

        // Показать/скрыть панель инструментов
        toggleToolboxBtn.addEventListener('click', () => {
            toolbox.classList.toggle('minimized');
            toggleToolboxBtn.classList.toggle('visible');
        });

        // Выбор инструмента
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Пропускаем кнопки рисования (они обрабатываются отдельно)
                if (btn.classList.contains('paint-tool-btn')) return;

                // ИСПРАВЛЕНО: Инструменты работают в обоих режимах
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                moleculeTool = btn.id.replace('tool-', '');
                currentTool = ''; // Сбрасываем инструмент рисования

                // Сбрасываем все состояния при смене инструмента
                selectedMoleculeUI = null;
                isDraggingMolecule = false;

                canvas.style.cursor = getCursorForTool(moleculeTool);
                status.textContent = `Tool: ${getToolName(moleculeTool)}`;
            });
        });

        // Курсор для каждого инструмента
        function getCursorForTool(tool) {
            // Кастомные курсоры с иконками инструментов
            // Формат: url(путь) hotspot-x hotspot-y, fallback
            switch(tool) {
                case 'select': return 'url(icons/select.png) 12 12, default';
                case 'create': return 'url(icons/create.png) 12 12, crosshair';
                case 'delete': return 'url(icons/delete.png) 12 12, not-allowed';
                default: return 'default';
            }
        }

        // Tool name
        function getToolName(tool) {
            switch(tool) {
                case 'select': return 'Select (mouse=move, Ctrl=size, Shift=stretch, Alt=rotate, wheel=size)';
                case 'create': return 'Create molecules';
                case 'delete': return 'Delete molecules';
                default: return 'Unknown tool';
            }
        }

        // Фиксация выбранной молекулы
        document.getElementById('action-lock').addEventListener('click', () => {
            if (selectedMoleculeUI) {
                selectedMoleculeUI.lock();
                saveState();
                status.textContent = 'Molecule locked';
            } else {
                status.textContent = 'First select molecule with Select tool';
            }
        });

        // Разблокировка выбранной молекулы
        document.getElementById('action-unlock').addEventListener('click', () => {
            if (selectedMoleculeUI) {
                selectedMoleculeUI.unlock();
                saveState();
                status.textContent = 'Molecule unlocked';
            } else {
                status.textContent = 'First select molecule with Select tool';
            }
        });

        // === МОБИЛЬНАЯ АДАПТАЦИЯ ПАНЕЛЕЙ ===
        const colorPalette = document.getElementById('colorPalette');
        const togglePaletteBtn = document.getElementById('togglePalette');
        const closePaletteBtn = document.getElementById('closePalette');
        const virtualControls = document.getElementById('virtualControls');

        // Автоматически сворачивать панели на мобильных устройствах
        if (isMobile) {
            // Сворачиваем панель управления на мобильных при старте
            controlsPanel.classList.add('mobile-collapsed');
            toggleControlsBtn.classList.add('visible');

            // Скрываем виртуальные кнопки (они неудобны, используем только жесты)
            virtualControls.style.display = 'none';
        }

        // Обработчики для палитры цветов
        function closePalette() {
            if (isMobile) {
                colorPalette.classList.add('mobile-collapsed');
                // Меняем иконку кнопки обратно на палитру
                togglePaletteBtn.textContent = '▼';
                togglePaletteBtn.title = 'Show palette';
            } else {
                colorPalette.classList.remove('active');
            }
        }

        closePaletteBtn.addEventListener('click', closePalette);
        closePaletteBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            closePalette();
        });

        // Функция для переключения палитры
        function togglePalette() {
            if (isMobile) {
                // Переключаем состояние палитры
                const isCollapsed = colorPalette.classList.contains('mobile-collapsed');
                console.log('togglePalette: isCollapsed =', isCollapsed); // Отладка
                if (isCollapsed) {
                    // Открываем палитру
                    colorPalette.classList.remove('mobile-collapsed');
                    // Кнопка остаётся видимой, только меняем иконку
                    togglePaletteBtn.textContent = '▲';
                    togglePaletteBtn.title = 'Скрыть палитру';
                    console.log('Palette opened'); // Отладка
                } else {
                    // Закрываем палитру
                    colorPalette.classList.add('mobile-collapsed');
                    // Кнопка остаётся видимой, возвращаем иконку
                    togglePaletteBtn.textContent = '▼';
                    togglePaletteBtn.title = 'Show palette';
                    console.log('Palette closed'); // Отладка
                }
            } else {
                colorPalette.classList.add('active');
            }
        }

        // Обработчик клика для десктопа
        togglePaletteBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            togglePalette();
        });

        // Обработчик touch для мобильных - используем touchstart для более быстрой реакции
        togglePaletteBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('🖱️ togglePalette touchstart fired!', {
                isMobile,
                paletteClasses: colorPalette.className,
                buttonClasses: togglePaletteBtn.className
            });
            togglePalette();
        }, { passive: false });

        // Дополнительный обработчик touchend на всякий случай
        togglePaletteBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });

        // Обновляем существующие обработчики для мобильных
        const originalCloseControls = closeControlsBtn.onclick;
        closeControlsBtn.addEventListener('click', (e) => {
            if (isMobile) {
                controlsPanel.classList.add('mobile-collapsed');
                toggleControlsBtn.classList.add('visible');
            }
        });

        const originalToggleControls = toggleControlsBtn.onclick;
        toggleControlsBtn.addEventListener('click', (e) => {
            if (isMobile) {
                controlsPanel.classList.remove('mobile-collapsed');
                toggleControlsBtn.classList.remove('visible');
            }
        });

        // === ВИРТУАЛЬНЫЕ КНОПКИ УПРАВЛЕНИЯ ===
        let virtualMode = null; // 'create', 'delete', 'move', 'scale-up', 'scale-down'

        // Обработчики для виртуальных кнопок
        document.querySelectorAll('.virtual-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const action = btn.dataset.action;

                // Если нажата та же кнопка - отключаем режим
                if (virtualMode === action) {
                    virtualMode = null;
                    btn.classList.remove('selected');
                } else {
                    // Снимаем выделение со всех кнопок
                    document.querySelectorAll('.virtual-btn').forEach(b => b.classList.remove('selected'));

                    // Выбираем новый режим
                    virtualMode = action;
                    btn.classList.add('selected');

                    // Для создания молекулы - делаем это сразу
                    if (action === 'create') {
                        // Ограничение количества молекул для производительности
                        if (molecules.length < maxMolecules) {
                            // Создаём молекулу в центре экрана
                            const centerX = width / 2;
                            const centerY = height / 2;
                            const newMol = new Molecule(centerX, centerY, currentMolSize);
                            newMol.shapes = [{type: selectedShape, weight: 1}];
                            molecules.push(newMol);
                            saveState(); // Сохраняем состояние для отмены
                        }

                        // Автоматически отключаем режим после создания
                        setTimeout(() => {
                            virtualMode = null;
                            btn.classList.remove('selected');
                        }, 100);
                    }
                }
            });
        });

        // Переменная для виртуальных кнопок
        let virtualSelectedMolecule = null;

        // === PAINT РЕЖИМ РЕДАКТОРА - UI ===

        // Инициализация палитры цветов
        function initColorPalette() {
            const colorGrid = document.getElementById('colorGrid');
            paintColors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.background = color;
                swatch.dataset.color = color;

                swatch.addEventListener('click', (e) => {
                    primaryColor = color;
                    document.getElementById('primaryColor').style.background = color;

                    // Снимаем выделение со всех
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                });

                colorGrid.appendChild(swatch);
            });

            // Обработчик для выбора произвольного цвета молекулы
            document.getElementById('customPrimaryColor').addEventListener('input', (e) => {
                primaryColor = e.target.value;
                document.getElementById('primaryColor').style.background = e.target.value;
                // Снимаем выделение со всех цветов палитры
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
            });

            // Инициализация палитры для мобильных устройств
            if (isMobile) {
                // При загрузке палитра скрыта (будет показана только в режиме редактора)
                colorPalette.classList.add('mobile-collapsed');
                console.log('📱 Палитра инициализирована для мобильных (скрыта)');
            }
        }

        // Переключение режима
        function toggleEditorMode() {
            editorMode = !editorMode;

            const modeBtn = document.getElementById('modeToggleBtn');
            const modeIndicator = document.getElementById('modeIndicator');
            const paintToolbar = document.getElementById('paintToolbar');
            // colorPalette уже определена глобально, используем её
            const controlsPanel = document.getElementById('controls');

            if (editorMode) {
                // Переход в режим редактора
                modeBtn.textContent = 'Gesture mode';

                modeIndicator.textContent = 'Editor mode';
                modeIndicator.className = 'mode-indicator editor-mode active';

                // УСТАРЕЛО: paintToolbar теперь часть #toolbox
                // paintToolbar.classList.add('active');

                // ИСПРАВЛЕНО: Панель инструментов доступна в обоих режимах
                // toolbox остается видимой

                // Показываем инструменты рисования в режиме редактора
                document.getElementById('paintToolsSection').style.display = 'block';

                // На мобильных показываем кнопку палитры, на десктопе открываем панель сразу
                if (isMobile) {
                    togglePaletteBtn.classList.add('visible');
                    colorPalette.classList.add('mobile-collapsed');
                    // Устанавливаем правильную иконку (палитра закрыта)
                    togglePaletteBtn.textContent = '▼';
                    togglePaletteBtn.title = 'Show palette';
                    console.log('📱 Режим редактора активирован на мобильном:', {
                        buttonVisible: togglePaletteBtn.classList.contains('visible'),
                        paletteCollapsed: colorPalette.classList.contains('mobile-collapsed')
                    });
                } else {
                    colorPalette.classList.add('active');
                }

                // ИСПРАВЛЕНО: Не замораживаем молекулы, они остаются "живыми"
                // Цвета и эффекты применяются напрямую к молекулам

                status.textContent = `Editor mode | Molecules: ${molecules.length}`;
            } else {
                // Возврат в режим жестов
                modeBtn.textContent = 'Editor mode';

                modeIndicator.textContent = 'Gesture mode';
                modeIndicator.className = 'mode-indicator gesture-mode active';

                // УСТАРЕЛО: paintToolbar теперь часть #toolbox
                // paintToolbar.classList.remove('active');

                // ИСПРАВЛЕНО: Панель инструментов всегда видима
                // Не нужно показывать/скрывать

                // Скрываем инструменты рисования в режиме жестов
                document.getElementById('paintToolsSection').style.display = 'none';

                // Скрываем палитру и кнопку палитры
                if (isMobile) {
                    colorPalette.classList.add('mobile-collapsed');
                    togglePaletteBtn.classList.remove('visible');

                    // Виртуальные кнопки остаются скрытыми на мобильных (они в меню)
                    // virtualControls остается display: none
                } else {
                    colorPalette.classList.remove('active');
                }

                selectedMolecule = null;

                // ИСПРАВЛЕНО: Цвета и эффекты уже применены напрямую к молекулам
                // Не нужно восстанавливать из frozenMolecules

                status.textContent = 'Gesture mode | Ready';
            }
        }

        // Обработчик кнопки переключения режима
        document.getElementById('modeToggleBtn').addEventListener('click', toggleEditorMode);

        // Выбор инструмента
        // Функция для выбора инструмента
        function selectTool(toolElement) {
            document.querySelectorAll('.paint-tool').forEach(t => t.classList.remove('selected'));
            toolElement.classList.add('selected');
            currentTool = toolElement.dataset.tool;

            // Меняем текст режима в зависимости от инструмента
            const fillModeLabel = document.getElementById('fillModeLabel');
            const pencilToolLabel = document.getElementById('pencilToolLabel');
            const smartEraserCheckbox = document.getElementById('smartEraserCheckbox');

            if (currentTool === 'eraser') {
                fillModeLabel.textContent = 'Режим ластика:';
                pencilToolLabel.textContent = 'Ластик:';
                smartEraserCheckbox.style.display = 'flex'; // Показываем чекбокс умного ластика
            } else if (currentTool === 'fill') {
                fillModeLabel.textContent = 'Режим заливки:';
                pencilToolLabel.textContent = 'Карандаш:';
                smartEraserCheckbox.style.display = 'none'; // Скрываем чекбокс
            } else if (currentTool === 'pencil') {
                fillModeLabel.textContent = 'Режим заливки:';
                pencilToolLabel.textContent = 'Карандаш:';
                smartEraserCheckbox.style.display = 'none'; // Скрываем чекбокс
            } else {
                fillModeLabel.textContent = 'Режим заливки:';
                pencilToolLabel.textContent = 'Карандаш:';
                smartEraserCheckbox.style.display = 'none'; // Скрываем чекбокс
            }
        }

        // Обработчики для кнопок инструментов (поддержка клика и тача)
        // УСТАРЕЛО: Старые кнопки .paint-tool теперь скрыты
        document.querySelectorAll('.paint-tool').forEach(tool => {
            tool.addEventListener('click', () => {
                selectTool(tool);
            });
            tool.addEventListener('touchend', (e) => {
                e.preventDefault();
                selectTool(tool);
            });
        });

        // НОВЫЕ: Обработчики для кнопок рисования в объединённой панели
        document.querySelectorAll('.paint-tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Снимаем выделение со всех инструментов
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                // Выделяем эту кнопку
                btn.classList.add('active');
                // Устанавливаем текущий инструмент
                currentTool = btn.dataset.tool;
                moleculeTool = ''; // Сбрасываем инструмент молекул

                // Обновляем интерфейс в зависимости от инструмента
                const fillModeLabel = document.getElementById('fillModeLabel');
                const pencilToolLabel = document.getElementById('pencilToolLabel');
                const smartEraserCheckbox = document.getElementById('smartEraserCheckbox');

                if (currentTool === 'fill') {
                    fillModeLabel.style.display = 'block';
                    pencilToolLabel.style.display = 'none';
                    smartEraserCheckbox.style.display = 'none';
                    status.textContent = `Tool: Fill (${fillMode})`;
                } else if (currentTool === 'pencil') {
                    fillModeLabel.style.display = 'none';
                    pencilToolLabel.style.display = 'block';
                    smartEraserCheckbox.style.display = 'none';
                    status.textContent = 'Tool: Pencil';
                } else if (currentTool === 'eraser') {
                    fillModeLabel.style.display = 'none';
                    pencilToolLabel.style.display = 'none';
                    smartEraserCheckbox.style.display = 'block';
                    status.textContent = smartEraserMode ? 'Tool: Smart eraser' : 'Tool: Eraser';
                }
            });
        });

        // Выбор режима заливки/ластика
        document.querySelectorAll('.fill-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Игнорируем кнопки без data-mode (например, кнопки фона)
                if (!btn.dataset.mode) return;

                document.querySelectorAll('.fill-mode-btn').forEach(b => {
                    if (b.dataset.mode) b.classList.remove('active');
                });
                btn.classList.add('active');
                fillMode = btn.dataset.mode;

                // Показываем разный текст в зависимости от инструмента
                const modeLabel = currentTool === 'eraser' ? 'Eraser mode' : 'Fill mode';
                status.textContent = `${modeLabel}: ${btn.textContent}`;
            });
        });

        // Выбор цвета фона
        document.getElementById('bgColorPicker').addEventListener('input', (e) => {
            backgroundColor = e.target.value;
            backgroundType = 'color';
            backgroundImage = null;
            backgroundCacheValid = false; // Инвалидируем кеш фона
            document.getElementById('bgPreview').textContent = `Color: ${backgroundColor}`;
            status.textContent = `Background: color ${backgroundColor}`;
        });

        // Загрузка файла для фона
        document.getElementById('bgFilePicker').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            const fileType = file.type;

            if (fileType.startsWith('image/')) {
                // Загружаем изображение
                const img = new Image();
                img.onload = () => {
                    backgroundImage = img;
                    backgroundType = 'image';
                    backgroundCacheValid = false; // Инвалидируем кеш фона
                    document.getElementById('bgPreview').textContent = `Image: ${file.name}`;
                    status.textContent = `Background: ${file.name}`;
                };
                img.src = url;
            } else if (fileType.startsWith('video/')) {
                // Загружаем видео
                const video = document.createElement('video');
                video.src = url;
                video.loop = true;
                video.muted = true;
                video.playsInline = true;
                video.play().then(() => {
                    backgroundImage = video;
                    backgroundType = 'video';
                    document.getElementById('bgPreview').textContent = `Video: ${file.name}`;
                    status.textContent = `Background: ${file.name}`;
                }).catch(err => {
                    console.error('Ошибка воспроизведения видео:', err);
                    status.textContent = 'Video loading error';
                });
            }
        });

        // Очистка фона
        document.getElementById('bgClearBtn').addEventListener('click', () => {
            backgroundColor = '#ffffff';
            backgroundImage = null;
            backgroundType = 'color';
            backgroundCacheValid = false; // Инвалидируем кеш фона
            document.getElementById('bgColorPicker').value = '#ffffff';
            document.getElementById('bgPreview').textContent = '';
            status.textContent = 'Background cleared (white)';
        });

        // Показ/скрытие настроек микрополосок
        document.getElementById('microStripesEffect').addEventListener('change', (e) => {
            const settings = document.getElementById('microStripesSettings');
            settings.style.display = e.target.checked ? 'flex' : 'none';
        });

        // Обновление значения ширины полосок
        document.getElementById('stripeWidth').addEventListener('input', (e) => {
            document.getElementById('stripeWidthValue').textContent = e.target.value;
        });

        // Обновление толщины карандаша
        document.getElementById('pencilWidth').addEventListener('input', (e) => {
            pencilWidth = parseInt(e.target.value);
            document.getElementById('pencilWidthValue').textContent = e.target.value;
        });

        // Переключение режима умного ластика
        document.getElementById('smartEraser').addEventListener('change', (e) => {
            smartEraserMode = e.target.checked;
            status.textContent = smartEraserMode ? 'Smart eraser: click deletes entire area' : 'Normal eraser: erases in parts';
        });

        // Очистка всех рисунков карандашом
        document.getElementById('clearDrawings').addEventListener('click', () => {
            if (drawnStrokes.length > 0 || filledRegions.length > 0 || backgroundFills.length > 0) {
                if (confirm('Delete all drawn strokes and filled areas?')) {
                    drawnStrokes = [];
                    filledRegions = [];
                    backgroundFills = [];
                    status.textContent = 'All drawings deleted';
                }
            } else {
                status.textContent = 'No drawings to delete';
            }
        });

        // Обновление значения расстояния между полосками
        document.getElementById('stripeSpacing').addEventListener('input', (e) => {
            document.getElementById('stripeSpacingValue').textContent = e.target.value;
        });

        // Перетаскивание палитры цветов
        (function() {
            const palette = document.getElementById('colorPalette');
            const handle = document.getElementById('paletteHandle');
            let isDragging = false;
            let offsetX = 0;
            let offsetY = 0;

            handle.addEventListener('mousedown', (e) => {
                isDragging = true;
                const rect = palette.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                palette.style.cursor = 'grabbing';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                // Вычисляем новую позицию
                let newLeft = e.clientX - offsetX;
                let newTop = e.clientY - offsetY;

                // Ограничиваем перемещение в пределах окна
                const paletteRect = palette.getBoundingClientRect();
                const maxLeft = window.innerWidth - paletteRect.width;
                const maxTop = window.innerHeight - paletteRect.height;

                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));

                // Убираем центрирование и используем абсолютные координаты
                palette.style.left = newLeft + 'px';
                palette.style.top = newTop + 'px';
                palette.style.bottom = 'auto';
                palette.style.transform = 'none';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    palette.style.cursor = '';
                }
            });
        })();

        // Движение мыши в режиме редактора - для подсветки
        canvas.addEventListener('mousemove', (e) => {
            if (!editorMode) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;

            // Находим молекулу под курсором
            hoveredMoleculeEditor = null;
            for (let i = molecules.length - 1; i >= 0; i--) {
                const mol = molecules[i];
                const dx = mouseX - mol.x;
                const dy = mouseY - mol.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < mol.size) {
                    hoveredMoleculeEditor = mol;
                    break;
                }
            }

            // Меняем курсор на кастомные иконки
            if (currentTool === 'fill') {
                canvas.style.cursor = hoveredMoleculeEditor ? 'pointer' : 'url(icons/fill.png) 12 12, crosshair';
            } else if (currentTool === 'pencil') {
                canvas.style.cursor = 'url(icons/pencil.png) 46 2, crosshair';
            } else if (currentTool === 'eraser') {
                canvas.style.cursor = hoveredMoleculeEditor ? 'pointer' : 'url(icons/eraser.png) 12 12, crosshair';
            }
        });

        // Клик на canvas в режиме редактора
        canvas.addEventListener('click', (e) => {
            if (!editorMode) return;
            // Работает только если НЕ выбран инструмент молекул
            if (moleculeTool) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            // Находим молекулу под курсором (используем hoveredMoleculeEditor для точности)
            let clickedMolecule = hoveredMoleculeEditor;

            if (currentTool === 'fill' && clickedMolecule) {
                // Заливка цветом в зависимости от режима
                if (fillMode === 'interior' || fillMode === 'both') {
                    clickedMolecule.fillColor = primaryColor;
                }
                if (fillMode === 'edge' || fillMode === 'both') {
                    clickedMolecule.edgeColor = primaryColor;
                }

                // Применяем эффекты если включены
                const embossCheckbox = document.getElementById('embossEffect');
                const microStripesCheckbox = document.getElementById('microStripesEffect');
                clickedMolecule.emboss = embossCheckbox.checked;
                clickedMolecule.microStripes = microStripesCheckbox.checked;

                // Сохраняем настройки микрополосок если эффект включен
                if (clickedMolecule.microStripes) {
                    clickedMolecule.stripeColor1 = document.getElementById('stripeColor1').value;
                    clickedMolecule.stripeColor2 = document.getElementById('stripeColor2').value;
                    clickedMolecule.stripeWidth = parseInt(document.getElementById('stripeWidth').value);
                    clickedMolecule.stripeSpacing = parseInt(document.getElementById('stripeSpacing').value);
                }

                // Обновляем замороженное состояние
                const molIndex = molecules.indexOf(clickedMolecule);
                if (frozenMolecules[molIndex]) {
                    if (fillMode === 'interior' || fillMode === 'both') {
                        frozenMolecules[molIndex].fillColor = primaryColor;
                    }
                    if (fillMode === 'edge' || fillMode === 'both') {
                        frozenMolecules[molIndex].edgeColor = primaryColor;
                    }
                    frozenMolecules[molIndex].emboss = clickedMolecule.emboss;
                    frozenMolecules[molIndex].microStripes = clickedMolecule.microStripes;
                    frozenMolecules[molIndex].stripeColor1 = clickedMolecule.stripeColor1;
                    frozenMolecules[molIndex].stripeColor2 = clickedMolecule.stripeColor2;
                    frozenMolecules[molIndex].stripeWidth = clickedMolecule.stripeWidth;
                    frozenMolecules[molIndex].stripeSpacing = clickedMolecule.stripeSpacing;
                }

                const modeText = fillMode === 'interior' ? 'interior' :
                                 fillMode === 'edge' ? 'edge' : 'interior+edge';
                const effectsText = [];
                if (clickedMolecule.emboss) effectsText.push('emboss');
                if (clickedMolecule.microStripes) effectsText.push('stripes');
                const effectsSuffix = effectsText.length > 0 ? ' + ' + effectsText.join(' + ') : '';
                status.textContent = `Filled ${modeText} with ${primaryColor}${effectsSuffix}`;
                saveState(); // Сохраняем состояние для отмены
            } else if (currentTool === 'fill' && !clickedMolecule) {
                // Заливка областей, нарисованных карандашом (flood fill)
                const fillResult = floodFillStrokes(clickX, clickY, primaryColor);
                if (fillResult === 'too_large') {
                    status.textContent = 'Area too large! Draw a closed shape with pencil';
                } else if (fillResult) {
                    // Определяем - фоновая заливка или обычная
                    const fillArea = fillResult.width * fillResult.height;
                    const canvasArea = canvas.width * canvas.height;
                    const areaRatio = fillArea / canvasArea;

                    // Если заливка занимает более 30% экрана - это фоновая заливка
                    const isBackground = areaRatio > 0.3;

                    if (isBackground) {
                        backgroundFills.push(fillResult);
                        status.textContent = `Background filled with ${primaryColor}`;
                        saveState(); // Сохраняем состояние для отмены
                    } else {
                        filledRegions.push(fillResult);
                        status.textContent = `Filled ${fillArea} pixels with ${primaryColor}`;
                        saveState(); // Сохраняем состояние для отмены
                    }
                } else {
                    status.textContent = 'Nothing to fill (click inside closed area)';
                }
            } else if (currentTool === 'eraser' && clickedMolecule) {
                // Ластик удаляет заливку в зависимости от режима
                if (fillMode === 'interior' || fillMode === 'both') {
                    clickedMolecule.fillColor = null;
                }
                if (fillMode === 'edge' || fillMode === 'both') {
                    clickedMolecule.edgeColor = null;
                }
                clickedMolecule.emboss = false; // Убираем тиснение
                clickedMolecule.microStripes = false; // Убираем полоски

                // Обновляем замороженное состояние
                const molIndex = molecules.indexOf(clickedMolecule);
                if (frozenMolecules[molIndex]) {
                    if (fillMode === 'interior' || fillMode === 'both') {
                        frozenMolecules[molIndex].fillColor = null;
                    }
                    if (fillMode === 'edge' || fillMode === 'both') {
                        frozenMolecules[molIndex].edgeColor = null;
                    }
                    frozenMolecules[molIndex].emboss = false;
                    frozenMolecules[molIndex].microStripes = false;
                }

                const modeText = fillMode === 'interior' ? 'interior' :
                                 fillMode === 'edge' ? 'edge' : 'interior+edge';
                status.textContent = `Erased ${modeText}`;
                saveState(); // Сохраняем состояние для отмены
            }
        });

        // Функция проверки пересечения точки с линией (для ластика)
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq != 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Функция заливки области (flood fill) - работает на отдельном слое
        function floodFillStrokes(startX, startY, fillColor) {
            // Создаём временный canvas для рисования только штрихов
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Рисуем все штрихи на временном canvas
            for (const stroke of drawnStrokes) {
                if (stroke.points.length < 2) continue;
                tempCtx.strokeStyle = stroke.color;
                tempCtx.lineWidth = stroke.width;
                tempCtx.lineCap = 'round';
                tempCtx.lineJoin = 'round';
                tempCtx.beginPath();
                tempCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    tempCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
                }
                tempCtx.stroke();
            }

            // Получаем imageData
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const pixels = imageData.data;
            const width = tempCanvas.width;
            const height = tempCanvas.height;

            // Сохраняем копию оригинального imageData для определения штрихов
            const originalPixels = new Uint8ClampedArray(pixels);

            startX = Math.floor(startX);
            startY = Math.floor(startY);

            if (startX < 0 || startX >= width || startY < 0 || startY >= height) {
                return null;
            }

            const startIndex = (startY * width + startX) * 4;
            const startR = pixels[startIndex];
            const startG = pixels[startIndex + 1];
            const startB = pixels[startIndex + 2];
            const startA = pixels[startIndex + 3];

            // Преобразуем цвет заливки в RGB
            const colorCanvas = document.createElement('canvas');
            colorCanvas.width = 1;
            colorCanvas.height = 1;
            const colorCtx = colorCanvas.getContext('2d');
            colorCtx.fillStyle = fillColor;
            colorCtx.fillRect(0, 0, 1, 1);
            const colorData = colorCtx.getImageData(0, 0, 1, 1).data;
            const fillR = colorData[0];
            const fillG = colorData[1];
            const fillB = colorData[2];
            const fillA = 255;

            // Если кликнули на штрих (непрозрачный пиксель), не заливаем
            if (startA !== 0) {
                return null;
            }

            const stack = [[startX, startY]];
            const visited = new Set();
            let minX = startX, maxX = startX, minY = startY, maxY = startY;

            function matchesStart(index) {
                return pixels[index] === startR &&
                       pixels[index + 1] === startG &&
                       pixels[index + 2] === startB &&
                       pixels[index + 3] === startA;
            }

            const MAX_FILL_AREA = 2000000; // Максимум 2 миллиона пикселей (достаточно для больших фигур)

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= width || y < 0 || y >= height) continue;

                const index = (y * width + x) * 4;

                if (!matchesStart(index)) continue;

                visited.add(key);

                // Проверяем размер области - если слишком большая, отменяем заливку
                if (visited.size > MAX_FILL_AREA) {
                    return 'too_large';
                }

                // Заливаем пиксель
                pixels[index] = fillR;
                pixels[index + 1] = fillG;
                pixels[index + 2] = fillB;
                pixels[index + 3] = fillA;

                // Обновляем границы
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);

                // Добавляем соседей
                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }

            if (visited.size === 0) return null;

            // Создаём обрезанный imageData только для залитой области
            const fillWidth = maxX - minX + 1;
            const fillHeight = maxY - minY + 1;
            const fillImageData = tempCtx.createImageData(fillWidth, fillHeight);

            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const srcIndex = (y * width + x) * 4;
                    const dstIndex = ((y - minY) * fillWidth + (x - minX)) * 4;

                    // Копируем только пиксели которые были прозрачными (НЕ штрихи)
                    // Если в оригинале пиксель был непрозрачным (штрих), оставляем прозрачным
                    if (originalPixels[srcIndex + 3] === 0) {
                        fillImageData.data[dstIndex] = pixels[srcIndex];
                        fillImageData.data[dstIndex + 1] = pixels[srcIndex + 1];
                        fillImageData.data[dstIndex + 2] = pixels[srcIndex + 2];
                        fillImageData.data[dstIndex + 3] = pixels[srcIndex + 3];
                    } else {
                        // Штрих - оставляем прозрачным
                        fillImageData.data[dstIndex] = 0;
                        fillImageData.data[dstIndex + 1] = 0;
                        fillImageData.data[dstIndex + 2] = 0;
                        fillImageData.data[dstIndex + 3] = 0;
                    }
                }
            }

            return {
                imageData: fillImageData,
                x: minX,
                y: minY,
                width: fillWidth,
                height: fillHeight
            };
        }

        // Обработчики мыши для карандаша и ластика
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // === ИНСТРУМЕНТЫ ДЛЯ МОЛЕКУЛ (работают в ОБОИХ режимах) ===
            // Работают только если НЕ выбран инструмент рисования
            if (moleculeTool && !currentTool && ['select', 'create', 'delete'].includes(moleculeTool)) {

                if (moleculeTool === 'select') {
                    // Выбираем молекулу под курсором
                    selectedMoleculeUI = null;

                    for (let i = molecules.length - 1; i >= 0; i--) {
                        const mol = molecules[i];
                        const dx = x - mol.x;
                        const dy = y - mol.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < mol.size * 1.5) {
                            selectedMoleculeUI = mol;
                            isDraggingMolecule = true;
                            // Сохраняем все начальные значения для возможного редактирования
                            dragOffsetX = dx;
                            dragOffsetY = dy;
                            editStartX = x;
                            editStartY = y;
                            editStartRadius = mol.size;
                            editStartStretchX = mol.stretchX;
                            editStartStretchY = mol.stretchY;
                            editStartAngle = mol.deformAngle;
                            status.textContent = 'Molecule selected (mouse=move, Ctrl=size, Shift=stretch, Alt=rotate)';
                            break;
                        }
                    }
                    if (!selectedMoleculeUI) {
                        status.textContent = 'Click molecule to select';
                    }
                } else if (moleculeTool === 'create') {
                    // Создаем новую молекулу с размером из панели параметров
                    const size = config.moleculeSize / 2; // Преобразуем размер в size для Molecule
                    const newMol = new Molecule(x, y, size);
                    newMol.shapes = [{type: selectedShape, weight: 1}];
                    newMol.vx = (Math.random() - 0.5) * 2;
                    newMol.vy = (Math.random() - 0.5) * 2;
                    molecules.push(newMol);
                    saveState();
                    status.textContent = `Created molecule (shape: ${selectedShape}, size: ${config.moleculeSize})`;
                } else if (moleculeTool === 'delete') {
                    // Удаляем молекулу под курсором
                    for (let i = molecules.length - 1; i >= 0; i--) {
                        const mol = molecules[i];
                        const dx = x - mol.x;
                        const dy = y - mol.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < mol.size * 1.5) {
                            molecules.splice(i, 1);
                            selectedMoleculeUI = null;
                            saveState();
                            status.textContent = 'Molecule deleted';
                            return;
                        }
                    }
                    status.textContent = 'Click molecule to delete';
                }
                return;
            }

            // === ИНСТРУМЕНТЫ РЕДАКТОРА (карандаш, ластик) ===
            if (!editorMode) return;
            if (currentTool !== 'pencil' && currentTool !== 'eraser') return;

            isDrawing = true;

            if (currentTool === 'pencil') {
                // Начинаем новый штрих
                currentStroke = {
                    points: [{x, y}],
                    color: primaryColor,
                    width: pencilWidth
                };
            } else if (currentTool === 'eraser') {
                if (smartEraserMode) {
                    // ✨ УМНЫЙ ЛАСТИК: удаляет целиком по одному клику
                    let deletedSomething = false;

                    // Удаляем штрих целиком (если режим edge или both)
                    if (fillMode === 'edge' || fillMode === 'both') {
                        const initialLength = drawnStrokes.length;
                        drawnStrokes = drawnStrokes.filter(stroke => {
                            // Проверяем попадает ли клик на этот штрих
                            for (const point of stroke.points) {
                                const dist = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                                if (dist < stroke.width * 2) {
                                    return false; // Удаляем весь штрих целиком
                                }
                            }
                            return true;
                        });
                        if (drawnStrokes.length < initialLength) {
                            deletedSomething = true;
                            status.textContent = 'Contour deleted';
                        }
                    }

                    // Удаляем залитую область целиком (если режим interior или both)
                    if (fillMode === 'interior' || fillMode === 'both') {
                        // Проверяем обычные заливки
                        const initialLength = filledRegions.length;
                        filledRegions = filledRegions.filter(region => {
                            // Проверяем попадает ли клик в эту область
                            if (x >= region.x && x < region.x + region.width &&
                                y >= region.y && y < region.y + region.height) {
                                // Проверяем не прозрачный ли пиксель под курсором
                                const px = Math.floor(x - region.x);
                                const py = Math.floor(y - region.y);
                                const idx = (py * region.width + px) * 4;
                                const alpha = region.imageData.data[idx + 3];
                                if (alpha > 0) {
                                    return false; // Удаляем всю область целиком
                                }
                            }
                            return true;
                        });

                        // Проверяем фоновые заливки
                        const initialBgLength = backgroundFills.length;
                        backgroundFills = backgroundFills.filter(region => {
                            // Проверяем попадает ли клик в эту область
                            if (x >= region.x && x < region.x + region.width &&
                                y >= region.y && y < region.y + region.height) {
                                // Проверяем не прозрачный ли пиксель под курсором
                                const px = Math.floor(x - region.x);
                                const py = Math.floor(y - region.y);
                                const idx = (py * region.width + px) * 4;
                                const alpha = region.imageData.data[idx + 3];
                                if (alpha > 0) {
                                    return false; // Удаляем всю область целиком
                                }
                            }
                            return true;
                        });

                        if (filledRegions.length < initialLength || backgroundFills.length < initialBgLength) {
                            deletedSomething = true;
                            status.textContent = 'Fill deleted';
                        }
                    }

                    if (!deletedSomething) {
                        status.textContent = 'Nothing to delete (click on contour or fill)';
                    }
                } else {
                    // ОБЫЧНЫЙ ЛАСТИК: работает при движении мыши (в mousemove)
                    // Здесь ничего не делаем, только начинаем isDrawing
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Сохраняем позицию мыши для вставки
            lastMouseX = x;
            lastMouseY = y;

            // === ПЕРЕМЕЩЕНИЕ И РЕДАКТИРОВАНИЕ МОЛЕКУЛ (работают в ОБОИХ режимах) ===
            // Работают только если НЕ выбран инструмент рисования
            if (!currentTool && isDraggingMolecule && selectedMoleculeUI) {
                // Проверяем зажатые клавиши-модификаторы для определения режима
                if (e.ctrlKey) {
                    // Ctrl: вертикальное движение = размер
                    const deltaY = editStartY - y; // Вверх = увеличение, вниз = уменьшение
                    const newSize = Math.max(15, Math.min(200, editStartRadius + deltaY * 0.5));
                    selectedMoleculeUI.size = newSize;
                    selectedMoleculeUI.targetSize = newSize;
                    selectedMoleculeUI.baseSize = newSize;
                    status.textContent = `Size: ${Math.round(newSize)}px (Ctrl+mouse up/down)`;
                } else if (e.altKey) {
                    // Alt: горизонтальное движение = вращение
                    const deltaX = (x - editStartX) * 0.01;
                    selectedMoleculeUI.deformAngle = (editStartAngle + deltaX) % (Math.PI * 2);
                    const degrees = (selectedMoleculeUI.deformAngle * 180 / Math.PI).toFixed(0);
                    status.textContent = `Rotation: ${degrees}° (Alt+mouse left/right)`;
                } else if (e.shiftKey) {
                    // Shift: свободное растяжение по обеим осям
                    const deltaX = (x - editStartX) * 0.01;
                    const deltaY = -(y - editStartY) * 0.01;
                    const newStretchX = Math.max(0.2, Math.min(5.0, editStartStretchX + deltaX));
                    const newStretchY = Math.max(0.2, Math.min(5.0, editStartStretchY + deltaY));
                    selectedMoleculeUI.stretchX = newStretchX;
                    selectedMoleculeUI.stretchY = newStretchY;
                    status.textContent = `Stretch X: ${newStretchX.toFixed(2)}, Y: ${newStretchY.toFixed(2)} (Shift+mouse)`;
                } else {
                    // Без модификаторов: перемещение
                    selectedMoleculeUI.x = x - dragOffsetX;
                    selectedMoleculeUI.y = y - dragOffsetY;
                    selectedMoleculeUI.targetX = selectedMoleculeUI.x;
                    selectedMoleculeUI.targetY = selectedMoleculeUI.y;
                    status.textContent = 'Moving (Ctrl=size, Shift=stretch, Alt=rotate)';
                }
                return;
            }

            // === КАРАНДАШ И ЛАСТИК ===
            if (!editorMode) return;
            if (currentTool !== 'pencil' && currentTool !== 'eraser') return;
            if (!isDrawing) return;

            if (currentTool === 'pencil') {
                // Добавляем точку к текущему штриху
                currentStroke.points.push({x, y});
            } else if (currentTool === 'eraser' && !smartEraserMode) {
                // ОБЫЧНЫЙ ЛАСТИК: стирает постепенно в области курсора (как заливку)
                const eraserSize = pencilWidth * 8; // Увеличили с *2 до *8 для удобства
                let erasedCount = 0;

                // Стираем штрихи под ластиком (если режим edge или both)
                if (fillMode === 'edge' || fillMode === 'both') {
                    // Помечаем точки штрихов как стертые, если они попадают под ластик
                    for (const stroke of drawnStrokes) {
                        for (let i = 0; i < stroke.points.length; i++) {
                            const point = stroke.points[i];

                            // Пропускаем уже стертые точки
                            if (point.erased) continue;

                            // Проверяем расстояние от точки до центра ластика
                            const dist = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);

                            if (dist < eraserSize) {
                                // Помечаем точку как стертую
                                point.erased = true;
                                erasedCount++;
                            }

                            // Также проверяем линию между текущей и предыдущей точкой
                            if (i > 0) {
                                const prevPoint = stroke.points[i - 1];
                                if (!prevPoint.erased) {
                                    const lineDist = distanceToLineSegment(x, y, prevPoint.x, prevPoint.y, point.x, point.y);

                                    if (lineDist < eraserSize) {
                                        // Стираем обе точки линии
                                        point.erased = true;
                                        prevPoint.erased = true;
                                        erasedCount += 2;
                                    }
                                }
                            }
                        }
                    }
                }

                if (erasedCount > 0) {
                    status.textContent = `Erasing contour (points erased: ${erasedCount})`;
                }

                // Стираем залитые области (если режим interior или both)
                if (fillMode === 'interior' || fillMode === 'both') {
                    // Стираем обычные заливки
                    for (const region of filledRegions) {
                        if (x >= region.x && x < region.x + region.width &&
                            y >= region.y && y < region.y + region.height) {
                            // Стираем круг в imageData
                            const pixels = region.imageData.data;
                            for (let dy = -eraserSize; dy <= eraserSize; dy++) {
                                for (let dx = -eraserSize; dx <= eraserSize; dx++) {
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist <= eraserSize) {
                                        const px = Math.floor(x - region.x + dx);
                                        const py = Math.floor(y - region.y + dy);
                                        if (px >= 0 && px < region.width && py >= 0 && py < region.height) {
                                            const idx = (py * region.width + px) * 4;
                                            pixels[idx + 3] = 0; // Делаем прозрачным
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Стираем фоновые заливки
                    for (const region of backgroundFills) {
                        if (x >= region.x && x < region.x + region.width &&
                            y >= region.y && y < region.y + region.height) {
                            // Стираем круг в imageData
                            const pixels = region.imageData.data;
                            for (let dy = -eraserSize; dy <= eraserSize; dy++) {
                                for (let dx = -eraserSize; dx <= eraserSize; dx++) {
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist <= eraserSize) {
                                        const px = Math.floor(x - region.x + dx);
                                        const py = Math.floor(y - region.y + dy);
                                        if (px >= 0 && px < region.width && py >= 0 && py < region.height) {
                                            const idx = (py * region.width + px) * 4;
                                            pixels[idx + 3] = 0; // Делаем прозрачным
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                status.textContent = `Strokes: ${drawnStrokes.length}, Regions: ${filledRegions.length}`;
            }
        });

        // Локальный обработчик mouseup на canvas
        canvas.addEventListener('mouseup', () => {
            // === ЗАВЕРШЕНИЕ ОПЕРАЦИЙ С МОЛЕКУЛАМИ ===
            // Работают только если НЕ выбран инструмент рисования
            if (!currentTool && isDraggingMolecule && selectedMoleculeUI) {
                isDraggingMolecule = false;
                saveState();
                status.textContent = 'Operation completed';
                return;
            }

            // === КАРАНДАШ И ЛАСТИК ===
            if (!editorMode) return;
            if (currentTool !== 'pencil' && currentTool !== 'eraser') return;
            if (!isDrawing) return;

            isDrawing = false;

            // Сохраняем завершенный штрих (только для карандаша)
            if (currentTool === 'pencil') {
                if (currentStroke && currentStroke.points.length > 1) {
                    drawnStrokes.push(currentStroke);
                    status.textContent = `Drew ${drawnStrokes.length} strokes`;
                    saveState(); // Сохраняем состояние для отмены
                }
                currentStroke = null;
            } else if (currentTool === 'eraser') {
                // Сохраняем состояние после стирания
                saveState();
            }
        });

        // Глобальный обработчик mouseup - на случай если кнопка отпущена вне canvas
        document.addEventListener('mouseup', () => {
            // === ЗАВЕРШЕНИЕ ОПЕРАЦИЙ С МОЛЕКУЛАМИ (глобально) ===
            // Работают только если НЕ выбран инструмент рисования
            if (!currentTool && isDraggingMolecule) {
                isDraggingMolecule = false;
                saveState();
                status.textContent = 'Operation completed';
                return;
            }

            // === КАРАНДАШ И ЛАСТИК ===
            if (!editorMode) return;
            if (currentTool !== 'pencil' && currentTool !== 'eraser') return;
            if (!isDrawing) return;

            isDrawing = false;

            // Сохраняем завершенный штрих (только для карандаша)
            if (currentTool === 'pencil') {
                if (currentStroke && currentStroke.points.length > 1) {
                    drawnStrokes.push(currentStroke);
                    status.textContent = `Drew ${drawnStrokes.length} strokes`;
                    saveState(); // Сохраняем состояние для отмены
                }
                currentStroke = null;
            } else if (currentTool === 'eraser') {
                // Сохраняем состояние после стирания
                saveState();
            }
        });

        // === ОБРАБОТЧИК КОЛЁСИКА МЫШИ ДЛЯ ИЗМЕНЕНИЯ РАЗМЕРА ===
        canvas.addEventListener('wheel', (e) => {
            // Работает только если выбрана молекула и активен инструмент select
            if (!currentTool && moleculeTool === 'select' && selectedMoleculeUI) {
                e.preventDefault(); // Предотвращаем прокрутку страницы

                // Определяем направление прокрутки (вверх = увеличение, вниз = уменьшение)
                const delta = -Math.sign(e.deltaY) * 5; // Шаг изменения размера
                const newSize = Math.max(15, Math.min(200, selectedMoleculeUI.size + delta));

                selectedMoleculeUI.size = newSize;
                selectedMoleculeUI.targetSize = newSize;
                selectedMoleculeUI.baseSize = newSize;

                status.textContent = `Size: ${Math.round(newSize)}px (mouse wheel)`;
            }
        }, { passive: false }); // passive: false чтобы preventDefault работал

        // === ОБРАБОТЧИК КЛАВИАТУРЫ ДЛЯ ОТМЕНЫ ДЕЙСТВИЙ ===
        document.addEventListener('keydown', (e) => {
            // Ctrl+Z или Cmd+Z (для Mac) - используем e.code для работы на любой раскладке
            if ((e.ctrlKey || e.metaKey) && e.code === 'KeyZ') {
                console.log(`⌨️ Нажата комбинация Ctrl+Z (раскладка: ${e.key})`);
                e.preventDefault(); // Предотвращаем стандартное поведение браузера
                undo();
            }

            // Ctrl+C или Cmd+C - копирование выбранной молекулы
            if ((e.ctrlKey || e.metaKey) && e.code === 'KeyC' && !editorMode) {
                if (selectedMoleculeUI) {
                    e.preventDefault();
                    // Копируем все свойства молекулы
                    copiedMolecule = {
                        size: selectedMoleculeUI.size,
                        baseSize: selectedMoleculeUI.baseSize,
                        targetSize: selectedMoleculeUI.targetSize,
                        stretchX: selectedMoleculeUI.stretchX,
                        stretchY: selectedMoleculeUI.stretchY,
                        deformAngle: selectedMoleculeUI.deformAngle,
                        shapes: JSON.parse(JSON.stringify(selectedMoleculeUI.shapes)), // Глубокая копия
                        fillColor: selectedMoleculeUI.fillColor,
                        edgeColor: selectedMoleculeUI.edgeColor,
                        emboss: selectedMoleculeUI.emboss,
                        isLocked: false, // Новая молекула не должна быть заблокирована
                        isShapeLocked: false
                    };
                    status.textContent = 'Molecule copied (Ctrl+V to paste)';
                } else {
                    status.textContent = 'Select molecule to copy';
                }
            }

            // Ctrl+V или Cmd+V - вставка молекулы
            if ((e.ctrlKey || e.metaKey) && e.code === 'KeyV' && !editorMode) {
                if (copiedMolecule) {
                    e.preventDefault();
                    // Создаем новую молекулу с копией свойств
                    const pasteX = lastMouseX || width / 2;
                    const pasteY = lastMouseY || height / 2;

                    const newMol = new Molecule(pasteX, pasteY, copiedMolecule.size);

                    // Копируем все свойства
                    newMol.baseSize = copiedMolecule.baseSize;
                    newMol.targetSize = copiedMolecule.targetSize;
                    newMol.stretchX = copiedMolecule.stretchX;
                    newMol.stretchY = copiedMolecule.stretchY;
                    newMol.deformAngle = copiedMolecule.deformAngle;
                    newMol.shapes = JSON.parse(JSON.stringify(copiedMolecule.shapes)); // Глубокая копия
                    newMol.fillColor = copiedMolecule.fillColor;
                    newMol.edgeColor = copiedMolecule.edgeColor;
                    newMol.emboss = copiedMolecule.emboss;
                    newMol.isLocked = copiedMolecule.isLocked;
                    newMol.isShapeLocked = copiedMolecule.isShapeLocked;

                    // Небольшая начальная скорость
                    newMol.vx = (Math.random() - 0.5) * 2;
                    newMol.vy = (Math.random() - 0.5) * 2;

                    molecules.push(newMol);
                    saveState();

                    // Выбираем вставленную молекулу
                    selectedMoleculeUI = newMol;
                    status.textContent = `Molecule pasted (x: ${Math.round(pasteX)}, y: ${Math.round(pasteY)})`;
                } else {
                    status.textContent = 'First copy a molecule (Ctrl+C)';
                }
            }

            // Delete - удаление выбранной молекулы
            if (e.code === 'Delete' && !editorMode) {
                if (selectedMoleculeUI) {
                    e.preventDefault();
                    const index = molecules.indexOf(selectedMoleculeUI);
                    if (index !== -1) {
                        molecules.splice(index, 1);
                        selectedMoleculeUI = null;
                        saveState();
                        status.textContent = 'Molecule deleted (Delete)';
                    }
                } else {
                    status.textContent = 'Select molecule to delete';
                }
            }
        });

        // === TOUCH СОБЫТИЯ ДЛЯ МОБИЛЬНЫХ УСТРОЙСТВ ===
        if (isTouchDevice) {
            let longPressTimer = null;
            const LONG_PRESS_DURATION = 500; // мс

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Предотвращаем скролл и zoom на мобильных

                const touches = e.touches;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                if (touches.length === 1) {
                    // Одиночное касание
                    const touch = touches[0];
                    const x = (touch.clientX - rect.left) * scaleX;
                    const y = (touch.clientY - rect.top) * scaleY;

                    // РЕЖИМ РЕДАКТОРА - обработка карандаша, ластика и заливки
                    if (editorMode) {
                        if (currentTool === 'pencil') {
                            isDrawing = true;
                            currentStroke = {
                                points: [{x, y}],
                                color: primaryColor,
                                width: pencilWidth
                            };
                        } else if (currentTool === 'eraser') {
                            isDrawing = true;

                            // Сначала проверяем попадание на молекулу для удаления заливки
                            let clickedMolecule = null;
                            for (let i = molecules.length - 1; i >= 0; i--) {
                                const mol = molecules[i];
                                const dx = x - mol.x;
                                const dy = y - mol.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance < mol.size) {
                                    clickedMolecule = mol;
                                    break;
                                }
                            }

                            if (clickedMolecule) {
                                // Удаляем заливку молекулы
                                if (fillMode === 'interior' || fillMode === 'both') {
                                    clickedMolecule.fillColor = null;
                                }
                                if (fillMode === 'edge' || fillMode === 'both') {
                                    clickedMolecule.edgeColor = null;
                                }
                                clickedMolecule.emboss = false;
                                clickedMolecule.microStripes = false;

                                // Обновляем frozenMolecules
                                const molIndex = molecules.indexOf(clickedMolecule);
                                if (frozenMolecules[molIndex]) {
                                    if (fillMode === 'interior' || fillMode === 'both') {
                                        frozenMolecules[molIndex].fillColor = null;
                                    }
                                    if (fillMode === 'edge' || fillMode === 'both') {
                                        frozenMolecules[molIndex].edgeColor = null;
                                    }
                                    frozenMolecules[molIndex].emboss = false;
                                    frozenMolecules[molIndex].microStripes = false;
                                }

                                const modeText = fillMode === 'interior' ? 'interior' :
                                                 fillMode === 'edge' ? 'edge' : 'interior+edge';
                                status.textContent = `Erased ${modeText} of molecule`;
                                saveState(); // Сохраняем состояние для отмены
                            } else if (smartEraserMode) {
                                // Умный ластик - удаляем штрихи и заливки целиком
                                let deletedSomething = false;
                                if (fillMode === 'edge' || fillMode === 'both') {
                                    const initialLength = drawnStrokes.length;
                                    drawnStrokes = drawnStrokes.filter(stroke => {
                                        for (const point of stroke.points) {
                                            const dist = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                                            if (dist < stroke.width * 2) return false;
                                        }
                                        return true;
                                    });
                                    if (drawnStrokes.length < initialLength) {
                                        deletedSomething = true;
                                        status.textContent = 'Contour deleted';
                                    }
                                }
                                if (fillMode === 'interior' || fillMode === 'both') {
                                    // Проверяем обычные заливки
                                    const initialLength = filledRegions.length;
                                    filledRegions = filledRegions.filter(region => {
                                        if (x >= region.x && x < region.x + region.width &&
                                            y >= region.y && y < region.y + region.height) {
                                            const px = Math.floor(x - region.x);
                                            const py = Math.floor(y - region.y);
                                            const idx = (py * region.width + px) * 4;
                                            const alpha = region.imageData.data[idx + 3];
                                            if (alpha > 0) return false;
                                        }
                                        return true;
                                    });

                                    // Проверяем фоновые заливки
                                    const initialBgLength = backgroundFills.length;
                                    backgroundFills = backgroundFills.filter(region => {
                                        if (x >= region.x && x < region.x + region.width &&
                                            y >= region.y && y < region.y + region.height) {
                                            const px = Math.floor(x - region.x);
                                            const py = Math.floor(y - region.y);
                                            const idx = (py * region.width + px) * 4;
                                            const alpha = region.imageData.data[idx + 3];
                                            if (alpha > 0) return false;
                                        }
                                        return true;
                                    });

                                    if (filledRegions.length < initialLength || backgroundFills.length < initialBgLength) {
                                        deletedSomething = true;
                                        status.textContent = 'Fill deleted';
                                    }
                                }
                                if (!deletedSomething) {
                                    status.textContent = 'Nothing to delete';
                                } else {
                                    saveState(); // Сохраняем состояние для отмены
                                }
                            }
                        } else if (currentTool === 'fill') {
                            // Заливка на мобильных - сначала проверяем попадание на молекулу
                            let clickedMolecule = null;
                            for (let i = molecules.length - 1; i >= 0; i--) {
                                const mol = molecules[i];
                                const dx = x - mol.x;
                                const dy = y - mol.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance < mol.size) {
                                    clickedMolecule = mol;
                                    break;
                                }
                            }

                            if (clickedMolecule) {
                                // Заливка молекулы
                                if (fillMode === 'interior' || fillMode === 'both') {
                                    clickedMolecule.fillColor = primaryColor;
                                }
                                if (fillMode === 'edge' || fillMode === 'both') {
                                    clickedMolecule.edgeColor = primaryColor;
                                }

                                // ВАЖНО: Обновляем frozenMolecules для сохранения после выхода из режима редактора
                                const molIndex = molecules.indexOf(clickedMolecule);
                                if (frozenMolecules[molIndex]) {
                                    if (fillMode === 'interior' || fillMode === 'both') {
                                        frozenMolecules[molIndex].fillColor = primaryColor;
                                    }
                                    if (fillMode === 'edge' || fillMode === 'both') {
                                        frozenMolecules[molIndex].edgeColor = primaryColor;
                                    }
                                }

                                status.textContent = 'Molecule filled with color';
                                saveState(); // Сохраняем состояние для отмены
                            } else {
                                // Заливка нарисованных областей
                                const fillResult = floodFillStrokes(x, y, primaryColor);
                                if (fillResult === 'too_large') {
                                    status.textContent = 'Area too large! Draw a closed shape';
                                } else if (fillResult) {
                                    // Определяем - фоновая заливка или обычная
                                    const fillArea = fillResult.width * fillResult.height;
                                    const canvasArea = canvas.width * canvas.height;
                                    const areaRatio = fillArea / canvasArea;

                                    // Если заливка занимает более 30% экрана - это фоновая заливка
                                    const isBackground = areaRatio > 0.3;

                                    if (isBackground) {
                                        backgroundFills.push(fillResult);
                                        status.textContent = `Background filled with ${primaryColor}`;
                                        saveState(); // Сохраняем состояние для отмены
                                    } else {
                                        filledRegions.push(fillResult);
                                        status.textContent = `Area filled with ${primaryColor}`;
                                        saveState(); // Сохраняем состояние для отмены
                                    }
                                } else {
                                    status.textContent = 'Cannot fill (no closed area)';
                                }
                            }
                        }
                        return; // Выходим из обработчика для режима редактора
                    }

                    // РЕЖИМ ЖЕСТОВ - обработка молекул

                    // Проверяем попадание на молекулу
                    touchedMolecule = null;
                    for (let i = molecules.length - 1; i >= 0; i--) {
                        const mol = molecules[i];
                        const dx = x - mol.x;
                        const dy = y - mol.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < mol.size) {
                            touchedMolecule = mol;
                            break;
                        }
                    }

                    if (touchedMolecule) {
                        // Если активен виртуальный режим - обрабатываем его
                        if (virtualMode) {
                            clearTimeout(longPressTimer);

                            if (virtualMode === 'delete') {
                                const index = molecules.indexOf(touchedMolecule);
                                if (index > -1) {
                                    molecules.splice(index, 1);
                                    status.textContent = `Molecule deleted | ${molecules.length}/${maxMolecules}`;
                                }
                                touchedMolecule = null;
                            } else if (virtualMode === 'scale-up') {
                                touchedMolecule.targetSize = Math.min(maxMoleculeSize, touchedMolecule.size + 20);
                                status.textContent = `Size: ${Math.round(touchedMolecule.targetSize)}`;
                            } else if (virtualMode === 'scale-down') {
                                touchedMolecule.targetSize = Math.max(minMoleculeSize, touchedMolecule.size - 20);
                                status.textContent = `Size: ${Math.round(touchedMolecule.targetSize)}`;
                            } else if (virtualMode === 'move') {
                                virtualSelectedMolecule = touchedMolecule;
                                touchedMolecule.isGrabbed = true;
                                status.textContent = 'Moving molecule';
                            }
                        } else {
                            // Стандартное поведение без виртуальных кнопок
                            // Начинаем длинное нажатие для удаления
                            longPressTimer = setTimeout(() => {
                                // Удаляем молекулу при длинном нажатии
                                const index = molecules.indexOf(touchedMolecule);
                                if (index > -1) {
                                    molecules.splice(index, 1);
                                    status.textContent = 'Molecule deleted (long press)';
                                    touchedMolecule = null;
                                }
                            }, LONG_PRESS_DURATION);

                            // Начинаем перемещение
                            touchedMolecule.isGrabbed = true;
                            touchedMolecule.targetX = x;
                            touchedMolecule.targetY = y;
                        }
                    } else if (!editorMode && molecules.length < maxMolecules) {
                        // Создаем новую молекулу только если НЕ активен виртуальный режим (кроме create)
                        if (!virtualMode || virtualMode === 'create') {
                            clearTimeout(longPressTimer);
                            const newMol = new Molecule(x, y, config.moleculeSize);
                            newMol.shapes = [{type: selectedShape, weight: 1}];
                            molecules.push(newMol);
                            touchedMolecule = newMol;
                            status.textContent = `Molecule created | ${molecules.length}/${maxMolecules}`;
                            saveState(); // Сохраняем состояние для отмены
                        }
                    }

                    activeTouches.set(touch.identifier, {x, y});

                } else if (touches.length === 2) {
                    // Два касания - режим pinch-to-zoom
                    clearTimeout(longPressTimer);

                    const touch1 = touches[0];
                    const touch2 = touches[1];

                    const x1 = (touch1.clientX - rect.left) * scaleX;
                    const y1 = (touch1.clientY - rect.top) * scaleY;
                    const x2 = (touch2.clientX - rect.left) * scaleX;
                    const y2 = (touch2.clientY - rect.top) * scaleY;

                    initialPinchDistance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

                    // Находим молекулу между двумя пальцами
                    const centerX = (x1 + x2) / 2;
                    const centerY = (y1 + y2) / 2;

                    touchedMolecule = null;
                    for (let i = molecules.length - 1; i >= 0; i--) {
                        const mol = molecules[i];
                        const dx = centerX - mol.x;
                        const dy = centerY - mol.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < mol.size * 2) {
                            touchedMolecule = mol;
                            break;
                        }
                    }

                    activeTouches.set(touch1.identifier, {x: x1, y: y1});
                    activeTouches.set(touch2.identifier, {x: x2, y: y2});
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();

                const touches = e.touches;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                // РЕЖИМ РЕДАКТОРА - рисование карандашом и стирание ластиком
                if (editorMode && isDrawing && touches.length === 1) {
                    const touch = touches[0];
                    const x = (touch.clientX - rect.left) * scaleX;
                    const y = (touch.clientY - rect.top) * scaleY;

                    if (currentTool === 'pencil' && currentStroke) {
                        currentStroke.points.push({x, y});
                    } else if (currentTool === 'eraser' && !smartEraserMode) {
                        // Обычный ластик стирает при движении
                        const eraserSize = pencilWidth * 2;
                        if (fillMode === 'edge' || fillMode === 'both') {
                            drawnStrokes = drawnStrokes.filter(stroke => {
                                for (const point of stroke.points) {
                                    const dist = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                                    if (dist < eraserSize) return false;
                                }
                                return true;
                            });
                        }
                        if (fillMode === 'interior' || fillMode === 'both') {
                            // Стираем обычные заливки
                            for (const region of filledRegions) {
                                if (x >= region.x && x < region.x + region.width &&
                                    y >= region.y && y < region.y + region.height) {
                                    const pixels = region.imageData.data;
                                    for (let dy = -eraserSize; dy <= eraserSize; dy++) {
                                        for (let dx = -eraserSize; dx <= eraserSize; dx++) {
                                            const dist = Math.sqrt(dx * dx + dy * dy);
                                            if (dist <= eraserSize) {
                                                const px = Math.floor(x - region.x + dx);
                                                const py = Math.floor(y - region.y + dy);
                                                if (px >= 0 && px < region.width && py >= 0 && py < region.height) {
                                                    const idx = (py * region.width + px) * 4;
                                                    pixels[idx + 3] = 0;
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            // Стираем фоновые заливки
                            for (const region of backgroundFills) {
                                if (x >= region.x && x < region.x + region.width &&
                                    y >= region.y && y < region.y + region.height) {
                                    const pixels = region.imageData.data;
                                    for (let dy = -eraserSize; dy <= eraserSize; dy++) {
                                        for (let dx = -eraserSize; dx <= eraserSize; dx++) {
                                            const dist = Math.sqrt(dx * dx + dy * dy);
                                            if (dist <= eraserSize) {
                                                const px = Math.floor(x - region.x + dx);
                                                const py = Math.floor(y - region.y + dy);
                                                if (px >= 0 && px < region.width && py >= 0 && py < region.height) {
                                                    const idx = (py * region.width + px) * 4;
                                                    pixels[idx + 3] = 0;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return;
                }

                // РЕЖИМ ЖЕСТОВ - перемещение молекул
                if (touches.length === 1 && touchedMolecule) {
                    // Перемещение молекулы одним пальцем
                    clearTimeout(longPressTimer); // Отменяем длинное нажатие при движении

                    const touch = touches[0];
                    const x = (touch.clientX - rect.left) * scaleX;
                    const y = (touch.clientY - rect.top) * scaleY;

                    touchedMolecule.targetX = x;
                    touchedMolecule.targetY = y;

                } else if (touches.length === 2 && touchedMolecule) {
                    // Масштабирование молекулы двумя пальцами (pinch)
                    clearTimeout(longPressTimer);

                    const touch1 = touches[0];
                    const touch2 = touches[1];

                    const x1 = (touch1.clientX - rect.left) * scaleX;
                    const y1 = (touch1.clientY - rect.top) * scaleY;
                    const x2 = (touch2.clientX - rect.left) * scaleX;
                    const y2 = (touch2.clientY - rect.top) * scaleY;

                    const currentDistance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    const scaleFactor = currentDistance / initialPinchDistance;

                    // Изменяем размер молекулы с адаптивными ограничениями
                    const newSize = Math.max(minMoleculeSize * 0.7, Math.min(maxMoleculeSize * 0.7, touchedMolecule.size * scaleFactor));
                    touchedMolecule.targetSize = newSize;

                    initialPinchDistance = currentDistance; // Обновляем для следующего кадра

                    // Также обновляем позицию молекулы к центру между пальцами
                    const centerX = (x1 + x2) / 2;
                    const centerY = (y1 + y2) / 2;
                    touchedMolecule.targetX = centerX;
                    touchedMolecule.targetY = centerY;

                    status.textContent = `Size: ${Math.round(newSize)}px (pinch)`;
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();

                // РЕЖИМ РЕДАКТОРА - завершение рисования
                if (editorMode && isDrawing) {
                    if (currentTool === 'pencil' && currentStroke && currentStroke.points.length > 0) {
                        drawnStrokes.push(currentStroke);
                        currentStroke = null;
                        status.textContent = `Stroke drawn | Total: ${drawnStrokes.length}`;
                        saveState(); // Сохраняем состояние для отмены
                    } else if (currentTool === 'eraser') {
                        // Сохраняем состояние после стирания
                        saveState();
                    }
                    isDrawing = false;
                    return;
                }

                // РЕЖИМ ЖЕСТОВ
                clearTimeout(longPressTimer);

                if (touchedMolecule) {
                    touchedMolecule.isGrabbed = false;
                }

                // Очищаем activeTouches
                const remainingTouches = e.touches;
                const remainingIds = new Set();
                for (let i = 0; i < remainingTouches.length; i++) {
                    remainingIds.add(remainingTouches[i].identifier);
                }

                for (const [id] of activeTouches) {
                    if (!remainingIds.has(id)) {
                        activeTouches.delete(id);
                    }
                }

                if (activeTouches.size === 0) {
                    touchedMolecule = null;
                    initialPinchDistance = 0;
                }
            }, { passive: false });

            canvas.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                clearTimeout(longPressTimer);

                if (touchedMolecule) {
                    touchedMolecule.isGrabbed = false;
                }

                activeTouches.clear();
                touchedMolecule = null;
                initialPinchDistance = 0;
            }, { passive: false });

            console.log('✅ Touch события для мобильных устройств добавлены');
        }

        // Инициализация
        async function init() {
            console.log('=== НАЧАЛО ИНИЦИАЛИЗАЦИИ ===');

            // Инициализируем палитру цветов Paint
            initColorPalette();

            resize();
            window.addEventListener('resize', resize);

            // Сохраняем начальное пустое состояние для возможности отмены первого действия
            saveState();

            console.log('Запускаем анимацию...');
            animate();

            console.log('Запрашиваем доступ к камере и микрофону...');
            const [camera, audio] = await Promise.all([
                setupCamera(),
                setupAudio()
            ]);

            console.log('Результаты инициализации - Камера:', camera, 'Аудио:', audio);

            if (camera && audio) {
                console.log('✅ ВСЁ УСПЕШНО ИНИЦИАЛИЗИРОВАНО');
                loading.style.display = 'none';
                status.textContent = 'Gesture mode | Ready';
                detectHands();
            } else {
                console.log('⚠️ Частичная инициализация - Камера:', !!camera, 'Аудио:', !!audio);
                loading.style.display = 'none';
                status.textContent = camera ? 'Running without sound' : 'Running without camera';
                if (camera) detectHands();
            }

            console.log('=== КОНЕЦ ИНИЦИАЛИЗАЦИИ ===');
        }

        console.log('🚀 Запуск приложения...');
        init();
    </script>

    <!-- Регистрация Service Worker для PWA -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('✅ Service Worker зарегистрирован:', registration.scope);
                    })
                    .catch(error => {
                        console.log('❌ Ошибка регистрации Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>
